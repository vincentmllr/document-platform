{"ast":null,"code":"/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n'use strict';\n\nconst debug = require('debug')('elasticsearch');\n\nconst os = require('os');\n\nconst {\n  gzip,\n  unzip,\n  createGzip\n} = require('zlib');\n\nconst buffer = require('buffer');\n\nconst ms = require('ms');\n\nconst {\n  ConnectionError,\n  RequestAbortedError,\n  NoLivingConnectionsError,\n  ResponseError,\n  ConfigurationError\n} = require('./errors');\n\nconst noop = () => {};\n\nconst clientVersion = require('../package.json').version;\n\nconst userAgent = `elasticsearch-js/${clientVersion} (${os.platform()} ${os.release()}-${os.arch()}; Node.js ${process.version})`;\nconst MAX_BUFFER_LENGTH = buffer.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = buffer.constants.MAX_STRING_LENGTH;\n\nclass Transport {\n  constructor(opts) {\n    if (typeof opts.compression === 'string' && opts.compression !== 'gzip') {\n      throw new ConfigurationError(`Invalid compression: '${opts.compression}'`);\n    }\n\n    this.emit = opts.emit;\n    this.connectionPool = opts.connectionPool;\n    this.serializer = opts.serializer;\n    this.maxRetries = opts.maxRetries;\n    this.requestTimeout = toMs(opts.requestTimeout);\n    this.suggestCompression = opts.suggestCompression === true;\n    this.compression = opts.compression || false;\n    this.context = opts.context || null;\n    this.headers = Object.assign({}, {\n      'user-agent': userAgent\n    }, opts.suggestCompression === true ? {\n      'accept-encoding': 'gzip,deflate'\n    } : null, lowerCaseHeaders(opts.headers));\n    this.sniffInterval = opts.sniffInterval;\n    this.sniffOnConnectionFault = opts.sniffOnConnectionFault;\n    this.sniffEndpoint = opts.sniffEndpoint;\n    this.generateRequestId = opts.generateRequestId || generateRequestId();\n    this.name = opts.name;\n    this.opaqueIdPrefix = opts.opaqueIdPrefix;\n    this.nodeFilter = opts.nodeFilter || defaultNodeFilter;\n\n    if (typeof opts.nodeSelector === 'function') {\n      this.nodeSelector = opts.nodeSelector;\n    } else if (opts.nodeSelector === 'round-robin') {\n      this.nodeSelector = roundRobinSelector();\n    } else if (opts.nodeSelector === 'random') {\n      this.nodeSelector = randomSelector;\n    } else {\n      this.nodeSelector = roundRobinSelector();\n    }\n\n    this._sniffEnabled = typeof this.sniffInterval === 'number';\n    this._nextSniff = this._sniffEnabled ? Date.now() + this.sniffInterval : 0;\n    this._isSniffing = false;\n\n    if (opts.sniffOnStart === true) {\n      this.sniff({\n        reason: Transport.sniffReasons.SNIFF_ON_START\n      });\n    }\n  }\n\n  request(params, options, callback) {\n    options = options || {};\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    let p = null; // promises support\n\n    if (callback === undefined) {\n      let onFulfilled = null;\n      let onRejected = null;\n      p = new Promise((resolve, reject) => {\n        onFulfilled = resolve;\n        onRejected = reject;\n      });\n\n      callback = function callback(err, result) {\n        err ? onRejected(err) : onFulfilled(result);\n      };\n    }\n\n    const meta = {\n      context: null,\n      request: {\n        params: null,\n        options: null,\n        id: options.id || this.generateRequestId(params, options)\n      },\n      name: this.name,\n      connection: null,\n      attempts: 0,\n      aborted: false\n    };\n\n    if (this.context != null && options.context != null) {\n      meta.context = Object.assign({}, this.context, options.context);\n    } else if (this.context != null) {\n      meta.context = this.context;\n    } else if (options.context != null) {\n      meta.context = options.context;\n    }\n\n    const result = {\n      body: null,\n      statusCode: null,\n      headers: null,\n      meta\n    };\n    Object.defineProperty(result, 'warnings', {\n      get() {\n        return this.headers && this.headers.warning ? this.headers.warning.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/) : null;\n      }\n\n    }); // We should not retry if we are sending a stream body, because we should store in memory\n    // a copy of the stream to be able to send it again, but since we don't know in advance\n    // the size of the stream, we risk to take too much memory.\n    // Furthermore, copying everytime the stream is very a expensive operation.\n\n    const maxRetries = isStream(params.body) || isStream(params.bulkBody) ? 0 : typeof options.maxRetries === 'number' ? options.maxRetries : this.maxRetries;\n    const compression = options.compression !== undefined ? options.compression : this.compression;\n    let request = {\n      abort: noop\n    };\n    const transportReturn = {\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n\n      abort() {\n        meta.aborted = true;\n        request.abort();\n        debug('Aborting request', params);\n        return this;\n      },\n\n      finally(onFinally) {\n        return p.finally(onFinally);\n      }\n\n    };\n\n    const makeRequest = () => {\n      if (meta.aborted === true) {\n        return process.nextTick(callback, new RequestAbortedError(), result);\n      }\n\n      meta.connection = this.getConnection({\n        requestId: meta.request.id\n      });\n\n      if (meta.connection == null) {\n        return process.nextTick(callback, new NoLivingConnectionsError(), result);\n      }\n\n      this.emit('request', null, result); // perform the actual http request\n\n      request = meta.connection.request(params, onResponse);\n    };\n\n    const onConnectionError = err => {\n      if (err.name !== 'RequestAbortedError') {\n        // if there is an error in the connection\n        // let's mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n\n        if (this.sniffOnConnectionFault === true) {\n          this.sniff({\n            reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n            requestId: meta.request.id\n          });\n        } // retry logic\n\n\n        if (meta.attempts < maxRetries) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      }\n\n      err.meta = result;\n      this.emit('response', err, result);\n      return callback(err, result);\n    };\n\n    const onResponse = (err, response) => {\n      if (err !== null) {\n        return onConnectionError(err);\n      }\n\n      result.statusCode = response.statusCode;\n      result.headers = response.headers;\n\n      if (options.asStream === true) {\n        result.body = response;\n        this.emit('response', null, result);\n        callback(null, result);\n        return;\n      }\n\n      const contentEncoding = (result.headers['content-encoding'] || '').toLowerCase();\n      const isCompressed = contentEncoding.indexOf('gzip') > -1 || contentEncoding.indexOf('deflate') > -1;\n      /* istanbul ignore else */\n\n      if (result.headers['content-length'] !== undefined) {\n        const contentLength = Number(result.headers['content-length']);\n\n        if (isCompressed && contentLength > MAX_BUFFER_LENGTH) {\n          response.destroy();\n          return onConnectionError(new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${MAX_BUFFER_LENGTH})`, result));\n        } else if (contentLength > MAX_STRING_LENGTH) {\n          response.destroy();\n          return onConnectionError(new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${MAX_STRING_LENGTH})`, result));\n        }\n      } // if the response is compressed, we must handle it\n      // as buffer for allowing decompression later\n\n\n      let payload = isCompressed ? [] : '';\n      const onData = isCompressed ? chunk => {\n        payload.push(chunk);\n      } : chunk => {\n        payload += chunk;\n      };\n\n      const onEnd = err => {\n        response.removeListener('data', onData);\n        response.removeListener('end', onEnd);\n        response.removeListener('error', onEnd);\n        response.removeListener('aborted', onAbort);\n\n        if (err) {\n          return onConnectionError(new ConnectionError(err.message));\n        }\n\n        if (isCompressed) {\n          unzip(Buffer.concat(payload), onBody);\n        } else {\n          onBody(null, payload);\n        }\n      };\n\n      const onAbort = () => {\n        response.destroy();\n        onEnd(new Error('Response aborted while reading the body'));\n      };\n\n      if (!isCompressed) {\n        response.setEncoding('utf8');\n      }\n\n      this.emit('deserialization', null, result);\n      response.on('data', onData);\n      response.on('error', onEnd);\n      response.on('end', onEnd);\n      response.on('aborted', onAbort);\n    };\n\n    const onBody = (err, payload) => {\n      if (err) {\n        this.emit('response', err, result);\n        return callback(err, result);\n      }\n\n      if (Buffer.isBuffer(payload)) {\n        payload = payload.toString();\n      }\n\n      const isHead = params.method === 'HEAD'; // we should attempt the payload deserialization only if:\n      //    - a `content-type` is defined and is equal to `application/json`\n      //    - the request is not a HEAD request\n      //    - the payload is not an empty string\n\n      if (result.headers['content-type'] !== undefined && result.headers['content-type'].indexOf('application/json') > -1 && isHead === false && payload !== '') {\n        try {\n          result.body = this.serializer.deserialize(payload);\n        } catch (err) {\n          this.emit('response', err, result);\n          return callback(err, result);\n        }\n      } else {\n        // cast to boolean if the request method was HEAD and there was no error\n        result.body = isHead === true && result.statusCode < 400 ? true : payload;\n      } // we should ignore the statusCode if the user has configured the `ignore` field with\n      // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n\n\n      const ignoreStatusCode = Array.isArray(options.ignore) && options.ignore.indexOf(result.statusCode) > -1 || isHead === true && result.statusCode === 404;\n\n      if (ignoreStatusCode === false && (result.statusCode === 502 || result.statusCode === 503 || result.statusCode === 504)) {\n        // if the statusCode is 502/3/4 we should run our retry strategy\n        // and mark the connection as dead\n        this.connectionPool.markDead(meta.connection); // retry logic (we shoukd not retry on \"429 - Too Many Requests\")\n\n        if (meta.attempts < maxRetries && result.statusCode !== 429) {\n          meta.attempts++;\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n          makeRequest();\n          return;\n        }\n      } else {\n        // everything has worked as expected, let's mark\n        // the connection as alive (or confirm it)\n        this.connectionPool.markAlive(meta.connection);\n      }\n\n      if (ignoreStatusCode === false && result.statusCode >= 400) {\n        const error = new ResponseError(result);\n        this.emit('response', error, result);\n        callback(error, result);\n      } else {\n        // cast to boolean if the request method was HEAD\n        if (isHead === true && result.statusCode === 404) {\n          result.body = false;\n        }\n\n        this.emit('response', null, result);\n        callback(null, result);\n      }\n    };\n\n    this.emit('serialization', null, result);\n    const headers = Object.assign({}, this.headers, lowerCaseHeaders(options.headers));\n\n    if (options.opaqueId !== undefined) {\n      headers['x-opaque-id'] = this.opaqueIdPrefix !== null ? this.opaqueIdPrefix + options.opaqueId : options.opaqueId;\n    } // handle json body\n\n\n    if (params.body != null) {\n      if (shouldSerialize(params.body) === true) {\n        try {\n          params.body = this.serializer.serialize(params.body);\n        } catch (err) {\n          this.emit('request', err, result);\n          process.nextTick(callback, err, result);\n          return transportReturn;\n        }\n      }\n\n      if (params.body !== '') {\n        headers['content-type'] = headers['content-type'] || 'application/json';\n      } // handle ndjson body\n\n    } else if (params.bulkBody != null) {\n      if (shouldSerialize(params.bulkBody) === true) {\n        try {\n          params.body = this.serializer.ndserialize(params.bulkBody);\n        } catch (err) {\n          this.emit('request', err, result);\n          process.nextTick(callback, err, result);\n          return transportReturn;\n        }\n      } else {\n        params.body = params.bulkBody;\n      }\n\n      if (params.body !== '') {\n        headers['content-type'] = headers['content-type'] || 'application/x-ndjson';\n      }\n    }\n\n    params.headers = headers; // serializes the querystring\n\n    if (options.querystring == null) {\n      params.querystring = this.serializer.qserialize(params.querystring);\n    } else {\n      params.querystring = this.serializer.qserialize(Object.assign({}, params.querystring, options.querystring));\n    } // handles request timeout\n\n\n    params.timeout = toMs(options.requestTimeout || this.requestTimeout);\n    if (options.asStream === true) params.asStream = true;\n    meta.request.params = params;\n    meta.request.options = options; // handle compression\n\n    if (params.body !== '' && params.body != null) {\n      if (isStream(params.body) === true) {\n        if (compression === 'gzip') {\n          params.headers['content-encoding'] = compression;\n          params.body = params.body.pipe(createGzip());\n        }\n\n        makeRequest();\n      } else if (compression === 'gzip') {\n        gzip(params.body, (err, buffer) => {\n          /* istanbul ignore next */\n          if (err) {\n            this.emit('request', err, result);\n            return callback(err, result);\n          }\n\n          params.headers['content-encoding'] = compression;\n          params.headers['content-length'] = '' + Buffer.byteLength(buffer);\n          params.body = buffer;\n          makeRequest();\n        });\n      } else {\n        params.headers['content-length'] = '' + Buffer.byteLength(params.body);\n        makeRequest();\n      }\n    } else {\n      makeRequest();\n    }\n\n    return transportReturn;\n  }\n\n  getConnection(opts) {\n    const now = Date.now();\n\n    if (this._sniffEnabled === true && now > this._nextSniff) {\n      this.sniff({\n        reason: Transport.sniffReasons.SNIFF_INTERVAL,\n        requestId: opts.requestId\n      });\n    }\n\n    return this.connectionPool.getConnection({\n      filter: this.nodeFilter,\n      selector: this.nodeSelector,\n      requestId: opts.requestId,\n      name: this.name,\n      now\n    });\n  }\n\n  sniff(opts, callback = noop) {\n    if (this._isSniffing === true) return;\n    this._isSniffing = true;\n    debug('Started sniffing request');\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {\n        reason: Transport.sniffReasons.DEFAULT\n      };\n    }\n\n    const {\n      reason\n    } = opts;\n    const request = {\n      method: 'GET',\n      path: this.sniffEndpoint\n    };\n    this.request(request, {\n      id: opts.requestId\n    }, (err, result) => {\n      this._isSniffing = false;\n\n      if (this._sniffEnabled === true) {\n        this._nextSniff = Date.now() + this.sniffInterval;\n      }\n\n      if (err != null) {\n        debug('Sniffing errored', err);\n        result.meta.sniff = {\n          hosts: [],\n          reason\n        };\n        this.emit('sniff', err, result);\n        return callback(err);\n      }\n\n      debug('Sniffing ended successfully', result.body);\n      const protocol = result.meta.connection.url.protocol ||\n      /* istanbul ignore next */\n      'http:';\n      const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n      this.connectionPool.update(hosts);\n      result.meta.sniff = {\n        hosts,\n        reason\n      };\n      this.emit('sniff', null, result);\n      callback(null, hosts);\n    });\n  }\n\n}\n\nTransport.sniffReasons = {\n  SNIFF_ON_START: 'sniff-on-start',\n  SNIFF_INTERVAL: 'sniff-interval',\n  SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n  // TODO: find a better name\n  DEFAULT: 'default'\n};\n\nfunction toMs(time) {\n  if (typeof time === 'string') {\n    return ms(time);\n  }\n\n  return time;\n}\n\nfunction shouldSerialize(obj) {\n  return typeof obj !== 'string' && typeof obj.pipe !== 'function' && Buffer.isBuffer(obj) === false;\n}\n\nfunction isStream(obj) {\n  return obj != null && typeof obj.pipe === 'function';\n}\n\nfunction defaultNodeFilter(node) {\n  // avoid master only nodes\n  if (node.roles.master === true && node.roles.data === false && node.roles.ingest === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction roundRobinSelector() {\n  let current = -1;\n  return function _roundRobinSelector(connections) {\n    if (++current >= connections.length) {\n      current = 0;\n    }\n\n    return connections[current];\n  };\n}\n\nfunction randomSelector(connections) {\n  const index = Math.floor(Math.random() * connections.length);\n  return connections[index];\n}\n\nfunction generateRequestId() {\n  const maxInt = 2147483647;\n  let nextReqId = 0;\n  return function genReqId(params, options) {\n    return nextReqId = nextReqId + 1 & maxInt;\n  };\n}\n\nfunction lowerCaseHeaders(oldHeaders) {\n  if (oldHeaders == null) return oldHeaders;\n  const newHeaders = {};\n\n  for (const header in oldHeaders) {\n    newHeaders[header.toLowerCase()] = oldHeaders[header];\n  }\n\n  return newHeaders;\n}\n\nmodule.exports = Transport;\nmodule.exports.internals = {\n  defaultNodeFilter,\n  roundRobinSelector,\n  randomSelector,\n  generateRequestId,\n  lowerCaseHeaders\n};","map":{"version":3,"sources":["C:/Users/vince/peer/project/app_react/src/node_modules/@elastic/elasticsearch/lib/Transport.js"],"names":["debug","require","os","gzip","unzip","createGzip","buffer","ms","ConnectionError","RequestAbortedError","NoLivingConnectionsError","ResponseError","ConfigurationError","noop","clientVersion","version","userAgent","platform","release","arch","process","MAX_BUFFER_LENGTH","constants","MAX_LENGTH","MAX_STRING_LENGTH","Transport","constructor","opts","compression","emit","connectionPool","serializer","maxRetries","requestTimeout","toMs","suggestCompression","context","headers","Object","assign","lowerCaseHeaders","sniffInterval","sniffOnConnectionFault","sniffEndpoint","generateRequestId","name","opaqueIdPrefix","nodeFilter","defaultNodeFilter","nodeSelector","roundRobinSelector","randomSelector","_sniffEnabled","_nextSniff","Date","now","_isSniffing","sniffOnStart","sniff","reason","sniffReasons","SNIFF_ON_START","request","params","options","callback","p","undefined","onFulfilled","onRejected","Promise","resolve","reject","err","result","meta","id","connection","attempts","aborted","body","statusCode","defineProperty","get","warning","split","isStream","bulkBody","abort","transportReturn","then","catch","finally","onFinally","makeRequest","nextTick","getConnection","requestId","onResponse","onConnectionError","markDead","SNIFF_ON_CONNECTION_FAULT","response","asStream","contentEncoding","toLowerCase","isCompressed","indexOf","contentLength","Number","destroy","payload","onData","chunk","push","onEnd","removeListener","onAbort","message","Buffer","concat","onBody","Error","setEncoding","on","isBuffer","toString","isHead","method","deserialize","ignoreStatusCode","Array","isArray","ignore","markAlive","error","opaqueId","shouldSerialize","serialize","ndserialize","querystring","qserialize","timeout","pipe","byteLength","SNIFF_INTERVAL","filter","selector","DEFAULT","path","hosts","protocol","url","nodesToHost","nodes","update","time","obj","node","roles","master","data","ingest","current","_roundRobinSelector","connections","length","index","Math","floor","random","maxInt","nextReqId","genReqId","oldHeaders","newHeaders","header","module","exports","internals"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,eAAjB,CAAd;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAM;AAAEE,EAAAA,IAAF;AAAQC,EAAAA,KAAR;AAAeC,EAAAA;AAAf,IAA8BJ,OAAO,CAAC,MAAD,CAA3C;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMM,EAAE,GAAGN,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAM;AACJO,EAAAA,eADI;AAEJC,EAAAA,mBAFI;AAGJC,EAAAA,wBAHI;AAIJC,EAAAA,aAJI;AAKJC,EAAAA;AALI,IAMFX,OAAO,CAAC,UAAD,CANX;;AAQA,MAAMY,IAAI,GAAG,MAAM,CAAE,CAArB;;AAEA,MAAMC,aAAa,GAAGb,OAAO,CAAC,iBAAD,CAAP,CAA2Bc,OAAjD;;AACA,MAAMC,SAAS,GAAI,oBAAmBF,aAAc,KAAIZ,EAAE,CAACe,QAAH,EAAc,IAAGf,EAAE,CAACgB,OAAH,EAAa,IAAGhB,EAAE,CAACiB,IAAH,EAAU,aAAYC,OAAO,CAACL,OAAQ,GAA/H;AACA,MAAMM,iBAAiB,GAAGf,MAAM,CAACgB,SAAP,CAAiBC,UAA3C;AACA,MAAMC,iBAAiB,GAAGlB,MAAM,CAACgB,SAAP,CAAiBE,iBAA3C;;AAEA,MAAMC,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAAEC,IAAF,EAAQ;AACjB,QAAI,OAAOA,IAAI,CAACC,WAAZ,KAA4B,QAA5B,IAAwCD,IAAI,CAACC,WAAL,KAAqB,MAAjE,EAAyE;AACvE,YAAM,IAAIhB,kBAAJ,CAAwB,yBAAwBe,IAAI,CAACC,WAAY,GAAjE,CAAN;AACD;;AAED,SAAKC,IAAL,GAAYF,IAAI,CAACE,IAAjB;AACA,SAAKC,cAAL,GAAsBH,IAAI,CAACG,cAA3B;AACA,SAAKC,UAAL,GAAkBJ,IAAI,CAACI,UAAvB;AACA,SAAKC,UAAL,GAAkBL,IAAI,CAACK,UAAvB;AACA,SAAKC,cAAL,GAAsBC,IAAI,CAACP,IAAI,CAACM,cAAN,CAA1B;AACA,SAAKE,kBAAL,GAA0BR,IAAI,CAACQ,kBAAL,KAA4B,IAAtD;AACA,SAAKP,WAAL,GAAmBD,IAAI,CAACC,WAAL,IAAoB,KAAvC;AACA,SAAKQ,OAAL,GAAeT,IAAI,CAACS,OAAL,IAAgB,IAA/B;AACA,SAAKC,OAAL,GAAeC,MAAM,CAACC,MAAP,CAAc,EAAd,EACb;AAAE,oBAAcvB;AAAhB,KADa,EAEbW,IAAI,CAACQ,kBAAL,KAA4B,IAA5B,GAAmC;AAAE,yBAAmB;AAArB,KAAnC,GAA2E,IAF9D,EAGbK,gBAAgB,CAACb,IAAI,CAACU,OAAN,CAHH,CAAf;AAKA,SAAKI,aAAL,GAAqBd,IAAI,CAACc,aAA1B;AACA,SAAKC,sBAAL,GAA8Bf,IAAI,CAACe,sBAAnC;AACA,SAAKC,aAAL,GAAqBhB,IAAI,CAACgB,aAA1B;AACA,SAAKC,iBAAL,GAAyBjB,IAAI,CAACiB,iBAAL,IAA0BA,iBAAiB,EAApE;AACA,SAAKC,IAAL,GAAYlB,IAAI,CAACkB,IAAjB;AACA,SAAKC,cAAL,GAAsBnB,IAAI,CAACmB,cAA3B;AAEA,SAAKC,UAAL,GAAkBpB,IAAI,CAACoB,UAAL,IAAmBC,iBAArC;;AACA,QAAI,OAAOrB,IAAI,CAACsB,YAAZ,KAA6B,UAAjC,EAA6C;AAC3C,WAAKA,YAAL,GAAoBtB,IAAI,CAACsB,YAAzB;AACD,KAFD,MAEO,IAAItB,IAAI,CAACsB,YAAL,KAAsB,aAA1B,EAAyC;AAC9C,WAAKA,YAAL,GAAoBC,kBAAkB,EAAtC;AACD,KAFM,MAEA,IAAIvB,IAAI,CAACsB,YAAL,KAAsB,QAA1B,EAAoC;AACzC,WAAKA,YAAL,GAAoBE,cAApB;AACD,KAFM,MAEA;AACL,WAAKF,YAAL,GAAoBC,kBAAkB,EAAtC;AACD;;AAED,SAAKE,aAAL,GAAqB,OAAO,KAAKX,aAAZ,KAA8B,QAAnD;AACA,SAAKY,UAAL,GAAkB,KAAKD,aAAL,GAAsBE,IAAI,CAACC,GAAL,KAAa,KAAKd,aAAxC,GAAyD,CAA3E;AACA,SAAKe,WAAL,GAAmB,KAAnB;;AAEA,QAAI7B,IAAI,CAAC8B,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,WAAKC,KAAL,CAAW;AAAEC,QAAAA,MAAM,EAAElC,SAAS,CAACmC,YAAV,CAAuBC;AAAjC,OAAX;AACD;AACF;;AAEDC,EAAAA,OAAO,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,QAAnB,EAA6B;AAClCD,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,MAAAA,QAAQ,GAAGD,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AACD,QAAIE,CAAC,GAAG,IAAR,CANkC,CAQlC;;AACA,QAAID,QAAQ,KAAKE,SAAjB,EAA4B;AAC1B,UAAIC,WAAW,GAAG,IAAlB;AACA,UAAIC,UAAU,GAAG,IAAjB;AACAH,MAAAA,CAAC,GAAG,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACnCJ,QAAAA,WAAW,GAAGG,OAAd;AACAF,QAAAA,UAAU,GAAGG,MAAb;AACD,OAHG,CAAJ;;AAIAP,MAAAA,QAAQ,GAAG,SAASA,QAAT,CAAmBQ,GAAnB,EAAwBC,MAAxB,EAAgC;AACzCD,QAAAA,GAAG,GAAGJ,UAAU,CAACI,GAAD,CAAb,GAAqBL,WAAW,CAACM,MAAD,CAAnC;AACD,OAFD;AAGD;;AAED,UAAMC,IAAI,GAAG;AACXvC,MAAAA,OAAO,EAAE,IADE;AAEX0B,MAAAA,OAAO,EAAE;AACPC,QAAAA,MAAM,EAAE,IADD;AAEPC,QAAAA,OAAO,EAAE,IAFF;AAGPY,QAAAA,EAAE,EAAEZ,OAAO,CAACY,EAAR,IAAc,KAAKhC,iBAAL,CAAuBmB,MAAvB,EAA+BC,OAA/B;AAHX,OAFE;AAOXnB,MAAAA,IAAI,EAAE,KAAKA,IAPA;AAQXgC,MAAAA,UAAU,EAAE,IARD;AASXC,MAAAA,QAAQ,EAAE,CATC;AAUXC,MAAAA,OAAO,EAAE;AAVE,KAAb;;AAaA,QAAI,KAAK3C,OAAL,IAAgB,IAAhB,IAAwB4B,OAAO,CAAC5B,OAAR,IAAmB,IAA/C,EAAqD;AACnDuC,MAAAA,IAAI,CAACvC,OAAL,GAAeE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKH,OAAvB,EAAgC4B,OAAO,CAAC5B,OAAxC,CAAf;AACD,KAFD,MAEO,IAAI,KAAKA,OAAL,IAAgB,IAApB,EAA0B;AAC/BuC,MAAAA,IAAI,CAACvC,OAAL,GAAe,KAAKA,OAApB;AACD,KAFM,MAEA,IAAI4B,OAAO,CAAC5B,OAAR,IAAmB,IAAvB,EAA6B;AAClCuC,MAAAA,IAAI,CAACvC,OAAL,GAAe4B,OAAO,CAAC5B,OAAvB;AACD;;AAED,UAAMsC,MAAM,GAAG;AACbM,MAAAA,IAAI,EAAE,IADO;AAEbC,MAAAA,UAAU,EAAE,IAFC;AAGb5C,MAAAA,OAAO,EAAE,IAHI;AAIbsC,MAAAA;AAJa,KAAf;AAOArC,IAAAA,MAAM,CAAC4C,cAAP,CAAsBR,MAAtB,EAA8B,UAA9B,EAA0C;AACxCS,MAAAA,GAAG,GAAI;AACL,eAAO,KAAK9C,OAAL,IAAgB,KAAKA,OAAL,CAAa+C,OAA7B,GACH,KAAK/C,OAAL,CAAa+C,OAAb,CAAqBC,KAArB,CAA2B,2BAA3B,CADG,GAEH,IAFJ;AAGD;;AALuC,KAA1C,EAjDkC,CAyDlC;AACA;AACA;AACA;;AACA,UAAMrD,UAAU,GAAGsD,QAAQ,CAACvB,MAAM,CAACiB,IAAR,CAAR,IAAyBM,QAAQ,CAACvB,MAAM,CAACwB,QAAR,CAAjC,GACf,CADe,GAEd,OAAOvB,OAAO,CAAChC,UAAf,KAA8B,QAA9B,GAAyCgC,OAAO,CAAChC,UAAjD,GAA8D,KAAKA,UAFxE;AAGA,UAAMJ,WAAW,GAAGoC,OAAO,CAACpC,WAAR,KAAwBuC,SAAxB,GAAoCH,OAAO,CAACpC,WAA5C,GAA0D,KAAKA,WAAnF;AACA,QAAIkC,OAAO,GAAG;AAAE0B,MAAAA,KAAK,EAAE3E;AAAT,KAAd;AACA,UAAM4E,eAAe,GAAG;AACtBC,MAAAA,IAAI,CAAEtB,WAAF,EAAeC,UAAf,EAA2B;AAC7B,eAAOH,CAAC,CAACwB,IAAF,CAAOtB,WAAP,EAAoBC,UAApB,CAAP;AACD,OAHqB;;AAItBsB,MAAAA,KAAK,CAAEtB,UAAF,EAAc;AACjB,eAAOH,CAAC,CAACyB,KAAF,CAAQtB,UAAR,CAAP;AACD,OANqB;;AAOtBmB,MAAAA,KAAK,GAAI;AACPb,QAAAA,IAAI,CAACI,OAAL,GAAe,IAAf;AACAjB,QAAAA,OAAO,CAAC0B,KAAR;AACAxF,QAAAA,KAAK,CAAC,kBAAD,EAAqB+D,MAArB,CAAL;AACA,eAAO,IAAP;AACD,OAZqB;;AAatB6B,MAAAA,OAAO,CAAEC,SAAF,EAAa;AAClB,eAAO3B,CAAC,CAAC0B,OAAF,CAAUC,SAAV,CAAP;AACD;;AAfqB,KAAxB;;AAkBA,UAAMC,WAAW,GAAG,MAAM;AACxB,UAAInB,IAAI,CAACI,OAAL,KAAiB,IAArB,EAA2B;AACzB,eAAO3D,OAAO,CAAC2E,QAAR,CAAiB9B,QAAjB,EAA2B,IAAIxD,mBAAJ,EAA3B,EAAsDiE,MAAtD,CAAP;AACD;;AACDC,MAAAA,IAAI,CAACE,UAAL,GAAkB,KAAKmB,aAAL,CAAmB;AAAEC,QAAAA,SAAS,EAAEtB,IAAI,CAACb,OAAL,CAAac;AAA1B,OAAnB,CAAlB;;AACA,UAAID,IAAI,CAACE,UAAL,IAAmB,IAAvB,EAA6B;AAC3B,eAAOzD,OAAO,CAAC2E,QAAR,CAAiB9B,QAAjB,EAA2B,IAAIvD,wBAAJ,EAA3B,EAA2DgE,MAA3D,CAAP;AACD;;AACD,WAAK7C,IAAL,CAAU,SAAV,EAAqB,IAArB,EAA2B6C,MAA3B,EARwB,CASxB;;AACAZ,MAAAA,OAAO,GAAGa,IAAI,CAACE,UAAL,CAAgBf,OAAhB,CAAwBC,MAAxB,EAAgCmC,UAAhC,CAAV;AACD,KAXD;;AAaA,UAAMC,iBAAiB,GAAI1B,GAAD,IAAS;AACjC,UAAIA,GAAG,CAAC5B,IAAJ,KAAa,qBAAjB,EAAwC;AACtC;AACA;AACA,aAAKf,cAAL,CAAoBsE,QAApB,CAA6BzB,IAAI,CAACE,UAAlC;;AAEA,YAAI,KAAKnC,sBAAL,KAAgC,IAApC,EAA0C;AACxC,eAAKgB,KAAL,CAAW;AACTC,YAAAA,MAAM,EAAElC,SAAS,CAACmC,YAAV,CAAuByC,yBADtB;AAETJ,YAAAA,SAAS,EAAEtB,IAAI,CAACb,OAAL,CAAac;AAFf,WAAX;AAID,SAVqC,CAYtC;;;AACA,YAAID,IAAI,CAACG,QAAL,GAAgB9C,UAApB,EAAgC;AAC9B2C,UAAAA,IAAI,CAACG,QAAL;AACA9E,UAAAA,KAAK,CAAE,qCAAoCgC,UAAU,GAAG2C,IAAI,CAACG,QAAS,WAAjE,EAA6Ef,MAA7E,CAAL;AACA+B,UAAAA,WAAW;AACX;AACD;AACF;;AAEDrB,MAAAA,GAAG,CAACE,IAAJ,GAAWD,MAAX;AACA,WAAK7C,IAAL,CAAU,UAAV,EAAsB4C,GAAtB,EAA2BC,MAA3B;AACA,aAAOT,QAAQ,CAACQ,GAAD,EAAMC,MAAN,CAAf;AACD,KAzBD;;AA2BA,UAAMwB,UAAU,GAAG,CAACzB,GAAD,EAAM6B,QAAN,KAAmB;AACpC,UAAI7B,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO0B,iBAAiB,CAAC1B,GAAD,CAAxB;AACD;;AAEDC,MAAAA,MAAM,CAACO,UAAP,GAAoBqB,QAAQ,CAACrB,UAA7B;AACAP,MAAAA,MAAM,CAACrC,OAAP,GAAiBiE,QAAQ,CAACjE,OAA1B;;AAEA,UAAI2B,OAAO,CAACuC,QAAR,KAAqB,IAAzB,EAA+B;AAC7B7B,QAAAA,MAAM,CAACM,IAAP,GAAcsB,QAAd;AACA,aAAKzE,IAAL,CAAU,UAAV,EAAsB,IAAtB,EAA4B6C,MAA5B;AACAT,QAAAA,QAAQ,CAAC,IAAD,EAAOS,MAAP,CAAR;AACA;AACD;;AAED,YAAM8B,eAAe,GAAG,CAAC9B,MAAM,CAACrC,OAAP,CAAe,kBAAf,KAAsC,EAAvC,EAA2CoE,WAA3C,EAAxB;AACA,YAAMC,YAAY,GAAGF,eAAe,CAACG,OAAhB,CAAwB,MAAxB,IAAkC,CAAC,CAAnC,IAAwCH,eAAe,CAACG,OAAhB,CAAwB,SAAxB,IAAqC,CAAC,CAAnG;AAEA;;AACA,UAAIjC,MAAM,CAACrC,OAAP,CAAe,gBAAf,MAAqC8B,SAAzC,EAAoD;AAClD,cAAMyC,aAAa,GAAGC,MAAM,CAACnC,MAAM,CAACrC,OAAP,CAAe,gBAAf,CAAD,CAA5B;;AACA,YAAIqE,YAAY,IAAIE,aAAa,GAAGvF,iBAApC,EAAuD;AACrDiF,UAAAA,QAAQ,CAACQ,OAAT;AACA,iBAAOX,iBAAiB,CACtB,IAAI1F,mBAAJ,CAAyB,uBAAsBmG,aAAc,gDAA+CvF,iBAAkB,GAA9H,EAAkIqD,MAAlI,CADsB,CAAxB;AAGD,SALD,MAKO,IAAIkC,aAAa,GAAGpF,iBAApB,EAAuC;AAC5C8E,UAAAA,QAAQ,CAACQ,OAAT;AACA,iBAAOX,iBAAiB,CACtB,IAAI1F,mBAAJ,CAAyB,uBAAsBmG,aAAc,gDAA+CpF,iBAAkB,GAA9H,EAAkIkD,MAAlI,CADsB,CAAxB;AAGD;AACF,OAhCmC,CAiCpC;AACA;;;AACA,UAAIqC,OAAO,GAAGL,YAAY,GAAG,EAAH,GAAQ,EAAlC;AACA,YAAMM,MAAM,GAAGN,YAAY,GACvBO,KAAK,IAAI;AAAEF,QAAAA,OAAO,CAACG,IAAR,CAAaD,KAAb;AAAqB,OADT,GAEvBA,KAAK,IAAI;AAAEF,QAAAA,OAAO,IAAIE,KAAX;AAAkB,OAFjC;;AAGA,YAAME,KAAK,GAAG1C,GAAG,IAAI;AACnB6B,QAAAA,QAAQ,CAACc,cAAT,CAAwB,MAAxB,EAAgCJ,MAAhC;AACAV,QAAAA,QAAQ,CAACc,cAAT,CAAwB,KAAxB,EAA+BD,KAA/B;AACAb,QAAAA,QAAQ,CAACc,cAAT,CAAwB,OAAxB,EAAiCD,KAAjC;AACAb,QAAAA,QAAQ,CAACc,cAAT,CAAwB,SAAxB,EAAmCC,OAAnC;;AAEA,YAAI5C,GAAJ,EAAS;AACP,iBAAO0B,iBAAiB,CAAC,IAAI3F,eAAJ,CAAoBiE,GAAG,CAAC6C,OAAxB,CAAD,CAAxB;AACD;;AAED,YAAIZ,YAAJ,EAAkB;AAChBtG,UAAAA,KAAK,CAACmH,MAAM,CAACC,MAAP,CAAcT,OAAd,CAAD,EAAyBU,MAAzB,CAAL;AACD,SAFD,MAEO;AACLA,UAAAA,MAAM,CAAC,IAAD,EAAOV,OAAP,CAAN;AACD;AACF,OAfD;;AAiBA,YAAMM,OAAO,GAAG,MAAM;AACpBf,QAAAA,QAAQ,CAACQ,OAAT;AACAK,QAAAA,KAAK,CAAC,IAAIO,KAAJ,CAAU,yCAAV,CAAD,CAAL;AACD,OAHD;;AAKA,UAAI,CAAChB,YAAL,EAAmB;AACjBJ,QAAAA,QAAQ,CAACqB,WAAT,CAAqB,MAArB;AACD;;AAED,WAAK9F,IAAL,CAAU,iBAAV,EAA6B,IAA7B,EAAmC6C,MAAnC;AACA4B,MAAAA,QAAQ,CAACsB,EAAT,CAAY,MAAZ,EAAoBZ,MAApB;AACAV,MAAAA,QAAQ,CAACsB,EAAT,CAAY,OAAZ,EAAqBT,KAArB;AACAb,MAAAA,QAAQ,CAACsB,EAAT,CAAY,KAAZ,EAAmBT,KAAnB;AACAb,MAAAA,QAAQ,CAACsB,EAAT,CAAY,SAAZ,EAAuBP,OAAvB;AACD,KAtED;;AAwEA,UAAMI,MAAM,GAAG,CAAChD,GAAD,EAAMsC,OAAN,KAAkB;AAC/B,UAAItC,GAAJ,EAAS;AACP,aAAK5C,IAAL,CAAU,UAAV,EAAsB4C,GAAtB,EAA2BC,MAA3B;AACA,eAAOT,QAAQ,CAACQ,GAAD,EAAMC,MAAN,CAAf;AACD;;AACD,UAAI6C,MAAM,CAACM,QAAP,CAAgBd,OAAhB,CAAJ,EAA8B;AAC5BA,QAAAA,OAAO,GAAGA,OAAO,CAACe,QAAR,EAAV;AACD;;AACD,YAAMC,MAAM,GAAGhE,MAAM,CAACiE,MAAP,KAAkB,MAAjC,CAR+B,CAS/B;AACA;AACA;AACA;;AACA,UAAItD,MAAM,CAACrC,OAAP,CAAe,cAAf,MAAmC8B,SAAnC,IACAO,MAAM,CAACrC,OAAP,CAAe,cAAf,EAA+BsE,OAA/B,CAAuC,kBAAvC,IAA6D,CAAC,CAD9D,IAEAoB,MAAM,KAAK,KAFX,IAGAhB,OAAO,KAAK,EAHhB,EAIE;AACA,YAAI;AACFrC,UAAAA,MAAM,CAACM,IAAP,GAAc,KAAKjD,UAAL,CAAgBkG,WAAhB,CAA4BlB,OAA5B,CAAd;AACD,SAFD,CAEE,OAAOtC,GAAP,EAAY;AACZ,eAAK5C,IAAL,CAAU,UAAV,EAAsB4C,GAAtB,EAA2BC,MAA3B;AACA,iBAAOT,QAAQ,CAACQ,GAAD,EAAMC,MAAN,CAAf;AACD;AACF,OAXD,MAWO;AACL;AACAA,QAAAA,MAAM,CAACM,IAAP,GAAc+C,MAAM,KAAK,IAAX,IAAmBrD,MAAM,CAACO,UAAP,GAAoB,GAAvC,GAA6C,IAA7C,GAAoD8B,OAAlE;AACD,OA3B8B,CA6B/B;AACA;;;AACA,YAAMmB,gBAAgB,GAAIC,KAAK,CAACC,OAAN,CAAcpE,OAAO,CAACqE,MAAtB,KAAiCrE,OAAO,CAACqE,MAAR,CAAe1B,OAAf,CAAuBjC,MAAM,CAACO,UAA9B,IAA4C,CAAC,CAA/E,IACtB8C,MAAM,KAAK,IAAX,IAAmBrD,MAAM,CAACO,UAAP,KAAsB,GAD5C;;AAGA,UAAIiD,gBAAgB,KAAK,KAArB,KACAxD,MAAM,CAACO,UAAP,KAAsB,GAAtB,IAA6BP,MAAM,CAACO,UAAP,KAAsB,GAAnD,IAA0DP,MAAM,CAACO,UAAP,KAAsB,GADhF,CAAJ,EAC0F;AACxF;AACA;AACA,aAAKnD,cAAL,CAAoBsE,QAApB,CAA6BzB,IAAI,CAACE,UAAlC,EAHwF,CAIxF;;AACA,YAAIF,IAAI,CAACG,QAAL,GAAgB9C,UAAhB,IAA8B0C,MAAM,CAACO,UAAP,KAAsB,GAAxD,EAA6D;AAC3DN,UAAAA,IAAI,CAACG,QAAL;AACA9E,UAAAA,KAAK,CAAE,qCAAoCgC,UAAU,GAAG2C,IAAI,CAACG,QAAS,WAAjE,EAA6Ef,MAA7E,CAAL;AACA+B,UAAAA,WAAW;AACX;AACD;AACF,OAZD,MAYO;AACL;AACA;AACA,aAAKhE,cAAL,CAAoBwG,SAApB,CAA8B3D,IAAI,CAACE,UAAnC;AACD;;AAED,UAAIqD,gBAAgB,KAAK,KAArB,IAA8BxD,MAAM,CAACO,UAAP,IAAqB,GAAvD,EAA4D;AAC1D,cAAMsD,KAAK,GAAG,IAAI5H,aAAJ,CAAkB+D,MAAlB,CAAd;AACA,aAAK7C,IAAL,CAAU,UAAV,EAAsB0G,KAAtB,EAA6B7D,MAA7B;AACAT,QAAAA,QAAQ,CAACsE,KAAD,EAAQ7D,MAAR,CAAR;AACD,OAJD,MAIO;AACL;AACA,YAAIqD,MAAM,KAAK,IAAX,IAAmBrD,MAAM,CAACO,UAAP,KAAsB,GAA7C,EAAkD;AAChDP,UAAAA,MAAM,CAACM,IAAP,GAAc,KAAd;AACD;;AACD,aAAKnD,IAAL,CAAU,UAAV,EAAsB,IAAtB,EAA4B6C,MAA5B;AACAT,QAAAA,QAAQ,CAAC,IAAD,EAAOS,MAAP,CAAR;AACD;AACF,KAhED;;AAkEA,SAAK7C,IAAL,CAAU,eAAV,EAA2B,IAA3B,EAAiC6C,MAAjC;AACA,UAAMrC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKF,OAAvB,EAAgCG,gBAAgB,CAACwB,OAAO,CAAC3B,OAAT,CAAhD,CAAhB;;AAEA,QAAI2B,OAAO,CAACwE,QAAR,KAAqBrE,SAAzB,EAAoC;AAClC9B,MAAAA,OAAO,CAAC,aAAD,CAAP,GAAyB,KAAKS,cAAL,KAAwB,IAAxB,GACrB,KAAKA,cAAL,GAAsBkB,OAAO,CAACwE,QADT,GAErBxE,OAAO,CAACwE,QAFZ;AAGD,KA7QiC,CA+QlC;;;AACA,QAAIzE,MAAM,CAACiB,IAAP,IAAe,IAAnB,EAAyB;AACvB,UAAIyD,eAAe,CAAC1E,MAAM,CAACiB,IAAR,CAAf,KAAiC,IAArC,EAA2C;AACzC,YAAI;AACFjB,UAAAA,MAAM,CAACiB,IAAP,GAAc,KAAKjD,UAAL,CAAgB2G,SAAhB,CAA0B3E,MAAM,CAACiB,IAAjC,CAAd;AACD,SAFD,CAEE,OAAOP,GAAP,EAAY;AACZ,eAAK5C,IAAL,CAAU,SAAV,EAAqB4C,GAArB,EAA0BC,MAA1B;AACAtD,UAAAA,OAAO,CAAC2E,QAAR,CAAiB9B,QAAjB,EAA2BQ,GAA3B,EAAgCC,MAAhC;AACA,iBAAOe,eAAP;AACD;AACF;;AAED,UAAI1B,MAAM,CAACiB,IAAP,KAAgB,EAApB,EAAwB;AACtB3C,QAAAA,OAAO,CAAC,cAAD,CAAP,GAA0BA,OAAO,CAAC,cAAD,CAAP,IAA2B,kBAArD;AACD,OAbsB,CAezB;;AACC,KAhBD,MAgBO,IAAI0B,MAAM,CAACwB,QAAP,IAAmB,IAAvB,EAA6B;AAClC,UAAIkD,eAAe,CAAC1E,MAAM,CAACwB,QAAR,CAAf,KAAqC,IAAzC,EAA+C;AAC7C,YAAI;AACFxB,UAAAA,MAAM,CAACiB,IAAP,GAAc,KAAKjD,UAAL,CAAgB4G,WAAhB,CAA4B5E,MAAM,CAACwB,QAAnC,CAAd;AACD,SAFD,CAEE,OAAOd,GAAP,EAAY;AACZ,eAAK5C,IAAL,CAAU,SAAV,EAAqB4C,GAArB,EAA0BC,MAA1B;AACAtD,UAAAA,OAAO,CAAC2E,QAAR,CAAiB9B,QAAjB,EAA2BQ,GAA3B,EAAgCC,MAAhC;AACA,iBAAOe,eAAP;AACD;AACF,OARD,MAQO;AACL1B,QAAAA,MAAM,CAACiB,IAAP,GAAcjB,MAAM,CAACwB,QAArB;AACD;;AACD,UAAIxB,MAAM,CAACiB,IAAP,KAAgB,EAApB,EAAwB;AACtB3C,QAAAA,OAAO,CAAC,cAAD,CAAP,GAA0BA,OAAO,CAAC,cAAD,CAAP,IAA2B,sBAArD;AACD;AACF;;AAED0B,IAAAA,MAAM,CAAC1B,OAAP,GAAiBA,OAAjB,CAjTkC,CAkTlC;;AACA,QAAI2B,OAAO,CAAC4E,WAAR,IAAuB,IAA3B,EAAiC;AAC/B7E,MAAAA,MAAM,CAAC6E,WAAP,GAAqB,KAAK7G,UAAL,CAAgB8G,UAAhB,CAA2B9E,MAAM,CAAC6E,WAAlC,CAArB;AACD,KAFD,MAEO;AACL7E,MAAAA,MAAM,CAAC6E,WAAP,GAAqB,KAAK7G,UAAL,CAAgB8G,UAAhB,CACnBvG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBwB,MAAM,CAAC6E,WAAzB,EAAsC5E,OAAO,CAAC4E,WAA9C,CADmB,CAArB;AAGD,KAzTiC,CA2TlC;;;AACA7E,IAAAA,MAAM,CAAC+E,OAAP,GAAiB5G,IAAI,CAAC8B,OAAO,CAAC/B,cAAR,IAA0B,KAAKA,cAAhC,CAArB;AACA,QAAI+B,OAAO,CAACuC,QAAR,KAAqB,IAAzB,EAA+BxC,MAAM,CAACwC,QAAP,GAAkB,IAAlB;AAC/B5B,IAAAA,IAAI,CAACb,OAAL,CAAaC,MAAb,GAAsBA,MAAtB;AACAY,IAAAA,IAAI,CAACb,OAAL,CAAaE,OAAb,GAAuBA,OAAvB,CA/TkC,CAiUlC;;AACA,QAAID,MAAM,CAACiB,IAAP,KAAgB,EAAhB,IAAsBjB,MAAM,CAACiB,IAAP,IAAe,IAAzC,EAA+C;AAC7C,UAAIM,QAAQ,CAACvB,MAAM,CAACiB,IAAR,CAAR,KAA0B,IAA9B,EAAoC;AAClC,YAAIpD,WAAW,KAAK,MAApB,EAA4B;AAC1BmC,UAAAA,MAAM,CAAC1B,OAAP,CAAe,kBAAf,IAAqCT,WAArC;AACAmC,UAAAA,MAAM,CAACiB,IAAP,GAAcjB,MAAM,CAACiB,IAAP,CAAY+D,IAAZ,CAAiB1I,UAAU,EAA3B,CAAd;AACD;;AACDyF,QAAAA,WAAW;AACZ,OAND,MAMO,IAAIlE,WAAW,KAAK,MAApB,EAA4B;AACjCzB,QAAAA,IAAI,CAAC4D,MAAM,CAACiB,IAAR,EAAc,CAACP,GAAD,EAAMnE,MAAN,KAAiB;AACjC;AACA,cAAImE,GAAJ,EAAS;AACP,iBAAK5C,IAAL,CAAU,SAAV,EAAqB4C,GAArB,EAA0BC,MAA1B;AACA,mBAAOT,QAAQ,CAACQ,GAAD,EAAMC,MAAN,CAAf;AACD;;AACDX,UAAAA,MAAM,CAAC1B,OAAP,CAAe,kBAAf,IAAqCT,WAArC;AACAmC,UAAAA,MAAM,CAAC1B,OAAP,CAAe,gBAAf,IAAmC,KAAKkF,MAAM,CAACyB,UAAP,CAAkB1I,MAAlB,CAAxC;AACAyD,UAAAA,MAAM,CAACiB,IAAP,GAAc1E,MAAd;AACAwF,UAAAA,WAAW;AACZ,SAVG,CAAJ;AAWD,OAZM,MAYA;AACL/B,QAAAA,MAAM,CAAC1B,OAAP,CAAe,gBAAf,IAAmC,KAAKkF,MAAM,CAACyB,UAAP,CAAkBjF,MAAM,CAACiB,IAAzB,CAAxC;AACAc,QAAAA,WAAW;AACZ;AACF,KAvBD,MAuBO;AACLA,MAAAA,WAAW;AACZ;;AAED,WAAOL,eAAP;AACD;;AAEDO,EAAAA,aAAa,CAAErE,IAAF,EAAQ;AACnB,UAAM4B,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;;AACA,QAAI,KAAKH,aAAL,KAAuB,IAAvB,IAA+BG,GAAG,GAAG,KAAKF,UAA9C,EAA0D;AACxD,WAAKK,KAAL,CAAW;AAAEC,QAAAA,MAAM,EAAElC,SAAS,CAACmC,YAAV,CAAuBqF,cAAjC;AAAiDhD,QAAAA,SAAS,EAAEtE,IAAI,CAACsE;AAAjE,OAAX;AACD;;AACD,WAAO,KAAKnE,cAAL,CAAoBkE,aAApB,CAAkC;AACvCkD,MAAAA,MAAM,EAAE,KAAKnG,UAD0B;AAEvCoG,MAAAA,QAAQ,EAAE,KAAKlG,YAFwB;AAGvCgD,MAAAA,SAAS,EAAEtE,IAAI,CAACsE,SAHuB;AAIvCpD,MAAAA,IAAI,EAAE,KAAKA,IAJ4B;AAKvCU,MAAAA;AALuC,KAAlC,CAAP;AAOD;;AAEDG,EAAAA,KAAK,CAAE/B,IAAF,EAAQsC,QAAQ,GAAGpD,IAAnB,EAAyB;AAC5B,QAAI,KAAK2C,WAAL,KAAqB,IAAzB,EAA+B;AAC/B,SAAKA,WAAL,GAAmB,IAAnB;AACAxD,IAAAA,KAAK,CAAC,0BAAD,CAAL;;AAEA,QAAI,OAAO2B,IAAP,KAAgB,UAApB,EAAgC;AAC9BsC,MAAAA,QAAQ,GAAGtC,IAAX;AACAA,MAAAA,IAAI,GAAG;AAAEgC,QAAAA,MAAM,EAAElC,SAAS,CAACmC,YAAV,CAAuBwF;AAAjC,OAAP;AACD;;AAED,UAAM;AAAEzF,MAAAA;AAAF,QAAahC,IAAnB;AAEA,UAAMmC,OAAO,GAAG;AACdkE,MAAAA,MAAM,EAAE,KADM;AAEdqB,MAAAA,IAAI,EAAE,KAAK1G;AAFG,KAAhB;AAKA,SAAKmB,OAAL,CAAaA,OAAb,EAAsB;AAAEc,MAAAA,EAAE,EAAEjD,IAAI,CAACsE;AAAX,KAAtB,EAA8C,CAACxB,GAAD,EAAMC,MAAN,KAAiB;AAC7D,WAAKlB,WAAL,GAAmB,KAAnB;;AACA,UAAI,KAAKJ,aAAL,KAAuB,IAA3B,EAAiC;AAC/B,aAAKC,UAAL,GAAkBC,IAAI,CAACC,GAAL,KAAa,KAAKd,aAApC;AACD;;AAED,UAAIgC,GAAG,IAAI,IAAX,EAAiB;AACfzE,QAAAA,KAAK,CAAC,kBAAD,EAAqByE,GAArB,CAAL;AACAC,QAAAA,MAAM,CAACC,IAAP,CAAYjB,KAAZ,GAAoB;AAAE4F,UAAAA,KAAK,EAAE,EAAT;AAAa3F,UAAAA;AAAb,SAApB;AACA,aAAK9B,IAAL,CAAU,OAAV,EAAmB4C,GAAnB,EAAwBC,MAAxB;AACA,eAAOT,QAAQ,CAACQ,GAAD,CAAf;AACD;;AAEDzE,MAAAA,KAAK,CAAC,6BAAD,EAAgC0E,MAAM,CAACM,IAAvC,CAAL;AACA,YAAMuE,QAAQ,GAAG7E,MAAM,CAACC,IAAP,CAAYE,UAAZ,CAAuB2E,GAAvB,CAA2BD,QAA3B;AAAuC;AAA2B,aAAnF;AACA,YAAMD,KAAK,GAAG,KAAKxH,cAAL,CAAoB2H,WAApB,CAAgC/E,MAAM,CAACM,IAAP,CAAY0E,KAA5C,EAAmDH,QAAnD,CAAd;AACA,WAAKzH,cAAL,CAAoB6H,MAApB,CAA2BL,KAA3B;AAEA5E,MAAAA,MAAM,CAACC,IAAP,CAAYjB,KAAZ,GAAoB;AAAE4F,QAAAA,KAAF;AAAS3F,QAAAA;AAAT,OAApB;AACA,WAAK9B,IAAL,CAAU,OAAV,EAAmB,IAAnB,EAAyB6C,MAAzB;AACAT,MAAAA,QAAQ,CAAC,IAAD,EAAOqF,KAAP,CAAR;AACD,KArBD;AAsBD;;AAnca;;AAschB7H,SAAS,CAACmC,YAAV,GAAyB;AACvBC,EAAAA,cAAc,EAAE,gBADO;AAEvBoF,EAAAA,cAAc,EAAE,gBAFO;AAGvB5C,EAAAA,yBAAyB,EAAE,2BAHJ;AAIvB;AACA+C,EAAAA,OAAO,EAAE;AALc,CAAzB;;AAQA,SAASlH,IAAT,CAAe0H,IAAf,EAAqB;AACnB,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,WAAOrJ,EAAE,CAACqJ,IAAD,CAAT;AACD;;AACD,SAAOA,IAAP;AACD;;AAED,SAASnB,eAAT,CAA0BoB,GAA1B,EAA+B;AAC7B,SAAO,OAAOA,GAAP,KAAe,QAAf,IACA,OAAOA,GAAG,CAACd,IAAX,KAAoB,UADpB,IAEAxB,MAAM,CAACM,QAAP,CAAgBgC,GAAhB,MAAyB,KAFhC;AAGD;;AAED,SAASvE,QAAT,CAAmBuE,GAAnB,EAAwB;AACtB,SAAOA,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAG,CAACd,IAAX,KAAoB,UAA1C;AACD;;AAED,SAAS/F,iBAAT,CAA4B8G,IAA5B,EAAkC;AAChC;AACA,MAAIA,IAAI,CAACC,KAAL,CAAWC,MAAX,KAAsB,IAAtB,IACAF,IAAI,CAACC,KAAL,CAAWE,IAAX,KAAoB,KADpB,IAEAH,IAAI,CAACC,KAAL,CAAWG,MAAX,KAAsB,KAF1B,EAEiC;AAC/B,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAAShH,kBAAT,GAA+B;AAC7B,MAAIiH,OAAO,GAAG,CAAC,CAAf;AACA,SAAO,SAASC,mBAAT,CAA8BC,WAA9B,EAA2C;AAChD,QAAI,EAAEF,OAAF,IAAaE,WAAW,CAACC,MAA7B,EAAqC;AACnCH,MAAAA,OAAO,GAAG,CAAV;AACD;;AACD,WAAOE,WAAW,CAACF,OAAD,CAAlB;AACD,GALD;AAMD;;AAED,SAAShH,cAAT,CAAyBkH,WAAzB,EAAsC;AACpC,QAAME,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBL,WAAW,CAACC,MAAvC,CAAd;AACA,SAAOD,WAAW,CAACE,KAAD,CAAlB;AACD;;AAED,SAAS3H,iBAAT,GAA8B;AAC5B,QAAM+H,MAAM,GAAG,UAAf;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,SAAO,SAASC,QAAT,CAAmB9G,MAAnB,EAA2BC,OAA3B,EAAoC;AACzC,WAAQ4G,SAAS,GAAIA,SAAS,GAAG,CAAb,GAAkBD,MAAtC;AACD,GAFD;AAGD;;AAED,SAASnI,gBAAT,CAA2BsI,UAA3B,EAAuC;AACrC,MAAIA,UAAU,IAAI,IAAlB,EAAwB,OAAOA,UAAP;AACxB,QAAMC,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAMC,MAAX,IAAqBF,UAArB,EAAiC;AAC/BC,IAAAA,UAAU,CAACC,MAAM,CAACvE,WAAP,EAAD,CAAV,GAAmCqE,UAAU,CAACE,MAAD,CAA7C;AACD;;AACD,SAAOD,UAAP;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiBzJ,SAAjB;AACAwJ,MAAM,CAACC,OAAP,CAAeC,SAAf,GAA2B;AACzBnI,EAAAA,iBADyB;AAEzBE,EAAAA,kBAFyB;AAGzBC,EAAAA,cAHyB;AAIzBP,EAAAA,iBAJyB;AAKzBJ,EAAAA;AALyB,CAA3B","sourcesContent":["/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\n'use strict'\r\n\r\nconst debug = require('debug')('elasticsearch')\r\nconst os = require('os')\r\nconst { gzip, unzip, createGzip } = require('zlib')\r\nconst buffer = require('buffer')\r\nconst ms = require('ms')\r\nconst {\r\n  ConnectionError,\r\n  RequestAbortedError,\r\n  NoLivingConnectionsError,\r\n  ResponseError,\r\n  ConfigurationError\r\n} = require('./errors')\r\n\r\nconst noop = () => {}\r\n\r\nconst clientVersion = require('../package.json').version\r\nconst userAgent = `elasticsearch-js/${clientVersion} (${os.platform()} ${os.release()}-${os.arch()}; Node.js ${process.version})`\r\nconst MAX_BUFFER_LENGTH = buffer.constants.MAX_LENGTH\r\nconst MAX_STRING_LENGTH = buffer.constants.MAX_STRING_LENGTH\r\n\r\nclass Transport {\r\n  constructor (opts) {\r\n    if (typeof opts.compression === 'string' && opts.compression !== 'gzip') {\r\n      throw new ConfigurationError(`Invalid compression: '${opts.compression}'`)\r\n    }\r\n\r\n    this.emit = opts.emit\r\n    this.connectionPool = opts.connectionPool\r\n    this.serializer = opts.serializer\r\n    this.maxRetries = opts.maxRetries\r\n    this.requestTimeout = toMs(opts.requestTimeout)\r\n    this.suggestCompression = opts.suggestCompression === true\r\n    this.compression = opts.compression || false\r\n    this.context = opts.context || null\r\n    this.headers = Object.assign({},\r\n      { 'user-agent': userAgent },\r\n      opts.suggestCompression === true ? { 'accept-encoding': 'gzip,deflate' } : null,\r\n      lowerCaseHeaders(opts.headers)\r\n    )\r\n    this.sniffInterval = opts.sniffInterval\r\n    this.sniffOnConnectionFault = opts.sniffOnConnectionFault\r\n    this.sniffEndpoint = opts.sniffEndpoint\r\n    this.generateRequestId = opts.generateRequestId || generateRequestId()\r\n    this.name = opts.name\r\n    this.opaqueIdPrefix = opts.opaqueIdPrefix\r\n\r\n    this.nodeFilter = opts.nodeFilter || defaultNodeFilter\r\n    if (typeof opts.nodeSelector === 'function') {\r\n      this.nodeSelector = opts.nodeSelector\r\n    } else if (opts.nodeSelector === 'round-robin') {\r\n      this.nodeSelector = roundRobinSelector()\r\n    } else if (opts.nodeSelector === 'random') {\r\n      this.nodeSelector = randomSelector\r\n    } else {\r\n      this.nodeSelector = roundRobinSelector()\r\n    }\r\n\r\n    this._sniffEnabled = typeof this.sniffInterval === 'number'\r\n    this._nextSniff = this._sniffEnabled ? (Date.now() + this.sniffInterval) : 0\r\n    this._isSniffing = false\r\n\r\n    if (opts.sniffOnStart === true) {\r\n      this.sniff({ reason: Transport.sniffReasons.SNIFF_ON_START })\r\n    }\r\n  }\r\n\r\n  request (params, options, callback) {\r\n    options = options || {}\r\n    if (typeof options === 'function') {\r\n      callback = options\r\n      options = {}\r\n    }\r\n    let p = null\r\n\r\n    // promises support\r\n    if (callback === undefined) {\r\n      let onFulfilled = null\r\n      let onRejected = null\r\n      p = new Promise((resolve, reject) => {\r\n        onFulfilled = resolve\r\n        onRejected = reject\r\n      })\r\n      callback = function callback (err, result) {\r\n        err ? onRejected(err) : onFulfilled(result)\r\n      }\r\n    }\r\n\r\n    const meta = {\r\n      context: null,\r\n      request: {\r\n        params: null,\r\n        options: null,\r\n        id: options.id || this.generateRequestId(params, options)\r\n      },\r\n      name: this.name,\r\n      connection: null,\r\n      attempts: 0,\r\n      aborted: false\r\n    }\r\n\r\n    if (this.context != null && options.context != null) {\r\n      meta.context = Object.assign({}, this.context, options.context)\r\n    } else if (this.context != null) {\r\n      meta.context = this.context\r\n    } else if (options.context != null) {\r\n      meta.context = options.context\r\n    }\r\n\r\n    const result = {\r\n      body: null,\r\n      statusCode: null,\r\n      headers: null,\r\n      meta\r\n    }\r\n\r\n    Object.defineProperty(result, 'warnings', {\r\n      get () {\r\n        return this.headers && this.headers.warning\r\n          ? this.headers.warning.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/)\r\n          : null\r\n      }\r\n    })\r\n\r\n    // We should not retry if we are sending a stream body, because we should store in memory\r\n    // a copy of the stream to be able to send it again, but since we don't know in advance\r\n    // the size of the stream, we risk to take too much memory.\r\n    // Furthermore, copying everytime the stream is very a expensive operation.\r\n    const maxRetries = isStream(params.body) || isStream(params.bulkBody)\r\n      ? 0\r\n      : (typeof options.maxRetries === 'number' ? options.maxRetries : this.maxRetries)\r\n    const compression = options.compression !== undefined ? options.compression : this.compression\r\n    let request = { abort: noop }\r\n    const transportReturn = {\r\n      then (onFulfilled, onRejected) {\r\n        return p.then(onFulfilled, onRejected)\r\n      },\r\n      catch (onRejected) {\r\n        return p.catch(onRejected)\r\n      },\r\n      abort () {\r\n        meta.aborted = true\r\n        request.abort()\r\n        debug('Aborting request', params)\r\n        return this\r\n      },\r\n      finally (onFinally) {\r\n        return p.finally(onFinally)\r\n      }\r\n    }\r\n\r\n    const makeRequest = () => {\r\n      if (meta.aborted === true) {\r\n        return process.nextTick(callback, new RequestAbortedError(), result)\r\n      }\r\n      meta.connection = this.getConnection({ requestId: meta.request.id })\r\n      if (meta.connection == null) {\r\n        return process.nextTick(callback, new NoLivingConnectionsError(), result)\r\n      }\r\n      this.emit('request', null, result)\r\n      // perform the actual http request\r\n      request = meta.connection.request(params, onResponse)\r\n    }\r\n\r\n    const onConnectionError = (err) => {\r\n      if (err.name !== 'RequestAbortedError') {\r\n        // if there is an error in the connection\r\n        // let's mark the connection as dead\r\n        this.connectionPool.markDead(meta.connection)\r\n\r\n        if (this.sniffOnConnectionFault === true) {\r\n          this.sniff({\r\n            reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\r\n            requestId: meta.request.id\r\n          })\r\n        }\r\n\r\n        // retry logic\r\n        if (meta.attempts < maxRetries) {\r\n          meta.attempts++\r\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params)\r\n          makeRequest()\r\n          return\r\n        }\r\n      }\r\n\r\n      err.meta = result\r\n      this.emit('response', err, result)\r\n      return callback(err, result)\r\n    }\r\n\r\n    const onResponse = (err, response) => {\r\n      if (err !== null) {\r\n        return onConnectionError(err)\r\n      }\r\n\r\n      result.statusCode = response.statusCode\r\n      result.headers = response.headers\r\n\r\n      if (options.asStream === true) {\r\n        result.body = response\r\n        this.emit('response', null, result)\r\n        callback(null, result)\r\n        return\r\n      }\r\n\r\n      const contentEncoding = (result.headers['content-encoding'] || '').toLowerCase()\r\n      const isCompressed = contentEncoding.indexOf('gzip') > -1 || contentEncoding.indexOf('deflate') > -1\r\n\r\n      /* istanbul ignore else */\r\n      if (result.headers['content-length'] !== undefined) {\r\n        const contentLength = Number(result.headers['content-length'])\r\n        if (isCompressed && contentLength > MAX_BUFFER_LENGTH) {\r\n          response.destroy()\r\n          return onConnectionError(\r\n            new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${MAX_BUFFER_LENGTH})`, result)\r\n          )\r\n        } else if (contentLength > MAX_STRING_LENGTH) {\r\n          response.destroy()\r\n          return onConnectionError(\r\n            new RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${MAX_STRING_LENGTH})`, result)\r\n          )\r\n        }\r\n      }\r\n      // if the response is compressed, we must handle it\r\n      // as buffer for allowing decompression later\r\n      let payload = isCompressed ? [] : ''\r\n      const onData = isCompressed\r\n        ? chunk => { payload.push(chunk) }\r\n        : chunk => { payload += chunk }\r\n      const onEnd = err => {\r\n        response.removeListener('data', onData)\r\n        response.removeListener('end', onEnd)\r\n        response.removeListener('error', onEnd)\r\n        response.removeListener('aborted', onAbort)\r\n\r\n        if (err) {\r\n          return onConnectionError(new ConnectionError(err.message))\r\n        }\r\n\r\n        if (isCompressed) {\r\n          unzip(Buffer.concat(payload), onBody)\r\n        } else {\r\n          onBody(null, payload)\r\n        }\r\n      }\r\n\r\n      const onAbort = () => {\r\n        response.destroy()\r\n        onEnd(new Error('Response aborted while reading the body'))\r\n      }\r\n\r\n      if (!isCompressed) {\r\n        response.setEncoding('utf8')\r\n      }\r\n\r\n      this.emit('deserialization', null, result)\r\n      response.on('data', onData)\r\n      response.on('error', onEnd)\r\n      response.on('end', onEnd)\r\n      response.on('aborted', onAbort)\r\n    }\r\n\r\n    const onBody = (err, payload) => {\r\n      if (err) {\r\n        this.emit('response', err, result)\r\n        return callback(err, result)\r\n      }\r\n      if (Buffer.isBuffer(payload)) {\r\n        payload = payload.toString()\r\n      }\r\n      const isHead = params.method === 'HEAD'\r\n      // we should attempt the payload deserialization only if:\r\n      //    - a `content-type` is defined and is equal to `application/json`\r\n      //    - the request is not a HEAD request\r\n      //    - the payload is not an empty string\r\n      if (result.headers['content-type'] !== undefined &&\r\n          result.headers['content-type'].indexOf('application/json') > -1 &&\r\n          isHead === false &&\r\n          payload !== ''\r\n      ) {\r\n        try {\r\n          result.body = this.serializer.deserialize(payload)\r\n        } catch (err) {\r\n          this.emit('response', err, result)\r\n          return callback(err, result)\r\n        }\r\n      } else {\r\n        // cast to boolean if the request method was HEAD and there was no error\r\n        result.body = isHead === true && result.statusCode < 400 ? true : payload\r\n      }\r\n\r\n      // we should ignore the statusCode if the user has configured the `ignore` field with\r\n      // the statusCode we just got or if the request method is HEAD and the statusCode is 404\r\n      const ignoreStatusCode = (Array.isArray(options.ignore) && options.ignore.indexOf(result.statusCode) > -1) ||\r\n        (isHead === true && result.statusCode === 404)\r\n\r\n      if (ignoreStatusCode === false &&\r\n         (result.statusCode === 502 || result.statusCode === 503 || result.statusCode === 504)) {\r\n        // if the statusCode is 502/3/4 we should run our retry strategy\r\n        // and mark the connection as dead\r\n        this.connectionPool.markDead(meta.connection)\r\n        // retry logic (we shoukd not retry on \"429 - Too Many Requests\")\r\n        if (meta.attempts < maxRetries && result.statusCode !== 429) {\r\n          meta.attempts++\r\n          debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params)\r\n          makeRequest()\r\n          return\r\n        }\r\n      } else {\r\n        // everything has worked as expected, let's mark\r\n        // the connection as alive (or confirm it)\r\n        this.connectionPool.markAlive(meta.connection)\r\n      }\r\n\r\n      if (ignoreStatusCode === false && result.statusCode >= 400) {\r\n        const error = new ResponseError(result)\r\n        this.emit('response', error, result)\r\n        callback(error, result)\r\n      } else {\r\n        // cast to boolean if the request method was HEAD\r\n        if (isHead === true && result.statusCode === 404) {\r\n          result.body = false\r\n        }\r\n        this.emit('response', null, result)\r\n        callback(null, result)\r\n      }\r\n    }\r\n\r\n    this.emit('serialization', null, result)\r\n    const headers = Object.assign({}, this.headers, lowerCaseHeaders(options.headers))\r\n\r\n    if (options.opaqueId !== undefined) {\r\n      headers['x-opaque-id'] = this.opaqueIdPrefix !== null\r\n        ? this.opaqueIdPrefix + options.opaqueId\r\n        : options.opaqueId\r\n    }\r\n\r\n    // handle json body\r\n    if (params.body != null) {\r\n      if (shouldSerialize(params.body) === true) {\r\n        try {\r\n          params.body = this.serializer.serialize(params.body)\r\n        } catch (err) {\r\n          this.emit('request', err, result)\r\n          process.nextTick(callback, err, result)\r\n          return transportReturn\r\n        }\r\n      }\r\n\r\n      if (params.body !== '') {\r\n        headers['content-type'] = headers['content-type'] || 'application/json'\r\n      }\r\n\r\n    // handle ndjson body\r\n    } else if (params.bulkBody != null) {\r\n      if (shouldSerialize(params.bulkBody) === true) {\r\n        try {\r\n          params.body = this.serializer.ndserialize(params.bulkBody)\r\n        } catch (err) {\r\n          this.emit('request', err, result)\r\n          process.nextTick(callback, err, result)\r\n          return transportReturn\r\n        }\r\n      } else {\r\n        params.body = params.bulkBody\r\n      }\r\n      if (params.body !== '') {\r\n        headers['content-type'] = headers['content-type'] || 'application/x-ndjson'\r\n      }\r\n    }\r\n\r\n    params.headers = headers\r\n    // serializes the querystring\r\n    if (options.querystring == null) {\r\n      params.querystring = this.serializer.qserialize(params.querystring)\r\n    } else {\r\n      params.querystring = this.serializer.qserialize(\r\n        Object.assign({}, params.querystring, options.querystring)\r\n      )\r\n    }\r\n\r\n    // handles request timeout\r\n    params.timeout = toMs(options.requestTimeout || this.requestTimeout)\r\n    if (options.asStream === true) params.asStream = true\r\n    meta.request.params = params\r\n    meta.request.options = options\r\n\r\n    // handle compression\r\n    if (params.body !== '' && params.body != null) {\r\n      if (isStream(params.body) === true) {\r\n        if (compression === 'gzip') {\r\n          params.headers['content-encoding'] = compression\r\n          params.body = params.body.pipe(createGzip())\r\n        }\r\n        makeRequest()\r\n      } else if (compression === 'gzip') {\r\n        gzip(params.body, (err, buffer) => {\r\n          /* istanbul ignore next */\r\n          if (err) {\r\n            this.emit('request', err, result)\r\n            return callback(err, result)\r\n          }\r\n          params.headers['content-encoding'] = compression\r\n          params.headers['content-length'] = '' + Buffer.byteLength(buffer)\r\n          params.body = buffer\r\n          makeRequest()\r\n        })\r\n      } else {\r\n        params.headers['content-length'] = '' + Buffer.byteLength(params.body)\r\n        makeRequest()\r\n      }\r\n    } else {\r\n      makeRequest()\r\n    }\r\n\r\n    return transportReturn\r\n  }\r\n\r\n  getConnection (opts) {\r\n    const now = Date.now()\r\n    if (this._sniffEnabled === true && now > this._nextSniff) {\r\n      this.sniff({ reason: Transport.sniffReasons.SNIFF_INTERVAL, requestId: opts.requestId })\r\n    }\r\n    return this.connectionPool.getConnection({\r\n      filter: this.nodeFilter,\r\n      selector: this.nodeSelector,\r\n      requestId: opts.requestId,\r\n      name: this.name,\r\n      now\r\n    })\r\n  }\r\n\r\n  sniff (opts, callback = noop) {\r\n    if (this._isSniffing === true) return\r\n    this._isSniffing = true\r\n    debug('Started sniffing request')\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts\r\n      opts = { reason: Transport.sniffReasons.DEFAULT }\r\n    }\r\n\r\n    const { reason } = opts\r\n\r\n    const request = {\r\n      method: 'GET',\r\n      path: this.sniffEndpoint\r\n    }\r\n\r\n    this.request(request, { id: opts.requestId }, (err, result) => {\r\n      this._isSniffing = false\r\n      if (this._sniffEnabled === true) {\r\n        this._nextSniff = Date.now() + this.sniffInterval\r\n      }\r\n\r\n      if (err != null) {\r\n        debug('Sniffing errored', err)\r\n        result.meta.sniff = { hosts: [], reason }\r\n        this.emit('sniff', err, result)\r\n        return callback(err)\r\n      }\r\n\r\n      debug('Sniffing ended successfully', result.body)\r\n      const protocol = result.meta.connection.url.protocol || /* istanbul ignore next */ 'http:'\r\n      const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol)\r\n      this.connectionPool.update(hosts)\r\n\r\n      result.meta.sniff = { hosts, reason }\r\n      this.emit('sniff', null, result)\r\n      callback(null, hosts)\r\n    })\r\n  }\r\n}\r\n\r\nTransport.sniffReasons = {\r\n  SNIFF_ON_START: 'sniff-on-start',\r\n  SNIFF_INTERVAL: 'sniff-interval',\r\n  SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\r\n  // TODO: find a better name\r\n  DEFAULT: 'default'\r\n}\r\n\r\nfunction toMs (time) {\r\n  if (typeof time === 'string') {\r\n    return ms(time)\r\n  }\r\n  return time\r\n}\r\n\r\nfunction shouldSerialize (obj) {\r\n  return typeof obj !== 'string' &&\r\n         typeof obj.pipe !== 'function' &&\r\n         Buffer.isBuffer(obj) === false\r\n}\r\n\r\nfunction isStream (obj) {\r\n  return obj != null && typeof obj.pipe === 'function'\r\n}\r\n\r\nfunction defaultNodeFilter (node) {\r\n  // avoid master only nodes\r\n  if (node.roles.master === true &&\r\n      node.roles.data === false &&\r\n      node.roles.ingest === false) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction roundRobinSelector () {\r\n  let current = -1\r\n  return function _roundRobinSelector (connections) {\r\n    if (++current >= connections.length) {\r\n      current = 0\r\n    }\r\n    return connections[current]\r\n  }\r\n}\r\n\r\nfunction randomSelector (connections) {\r\n  const index = Math.floor(Math.random() * connections.length)\r\n  return connections[index]\r\n}\r\n\r\nfunction generateRequestId () {\r\n  const maxInt = 2147483647\r\n  let nextReqId = 0\r\n  return function genReqId (params, options) {\r\n    return (nextReqId = (nextReqId + 1) & maxInt)\r\n  }\r\n}\r\n\r\nfunction lowerCaseHeaders (oldHeaders) {\r\n  if (oldHeaders == null) return oldHeaders\r\n  const newHeaders = {}\r\n  for (const header in oldHeaders) {\r\n    newHeaders[header.toLowerCase()] = oldHeaders[header]\r\n  }\r\n  return newHeaders\r\n}\r\n\r\nmodule.exports = Transport\r\nmodule.exports.internals = {\r\n  defaultNodeFilter,\r\n  roundRobinSelector,\r\n  randomSelector,\r\n  generateRequestId,\r\n  lowerCaseHeaders\r\n}\r\n"]},"metadata":{},"sourceType":"module"}