{"ast":null,"code":"/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n'use strict';\n/* eslint camelcase: 0 */\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  ResponseError,\n  ConfigurationError\n} = require('./errors');\n\nconst pImmediate = promisify(setImmediate);\nconst sleep = promisify(setTimeout);\nconst kClient = Symbol('elasticsearch-client');\nconst kMetaHeader = Symbol('meta header');\n/* istanbul ignore next */\n\nconst noop = () => {};\n\nclass Helpers {\n  constructor(opts) {\n    this[kClient] = opts.client;\n    this[kMetaHeader] = opts.metaHeader;\n    this.maxRetries = opts.maxRetries;\n  }\n  /**\r\n   * Runs a search operation. The only difference between client.search and this utility,\r\n   * is that we are only returning the hits to the user and not the full ES response.\r\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\r\n   * as it will only need the documents source.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {array} The documents that matched the request.\r\n   */\n\n\n  async search(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n    const {\n      body\n    } = await this[kClient].search(params, options);\n\n    if (body.hits && body.hits.hits) {\n      return body.hits.hits.map(d => d._source);\n    }\n\n    return [];\n  }\n  /**\r\n   * Runs a scroll search operation. This function returns an async iterator, allowing\r\n   * the user to use a for await loop to get all the results of a given search.\r\n   * ```js\r\n   * for await (const result of client.helpers.scrollSearch({ params })) {\r\n   *   console.log(result)\r\n   * }\r\n   * ```\r\n   * Each result represents the entire body of a single scroll search request,\r\n   * if you just need to scroll the results, use scrollDocuments.\r\n   * This function handles automatically retries on 429 status code.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {iterator} the async iterator\r\n   */\n\n\n  async *scrollSearch(params, options = {}) {\n    if (this[kMetaHeader] !== null) {\n      options.headers = options.headers || {};\n      options.headers['x-elastic-client-meta'] = this[kMetaHeader] + ',h=s';\n    } // TODO: study scroll search slices\n\n\n    const wait = options.wait || 5000;\n    const maxRetries = options.maxRetries || this.maxRetries;\n\n    if (Array.isArray(options.ignore)) {\n      options.ignore.push(429);\n    } else {\n      options.ignore = [429];\n    }\n\n    params.scroll = params.scroll || '1m';\n    appendFilterPath('_scroll_id', params, false);\n    const {\n      method,\n      body,\n      index,\n      ...querystring\n    } = params;\n    let response = null;\n\n    for (let i = 0; i <= maxRetries; i++) {\n      response = await this[kClient].search(params, options);\n      if (response.statusCode !== 429) break;\n      await sleep(wait);\n    }\n\n    if (response.statusCode === 429) {\n      throw new ResponseError(response);\n    }\n\n    let scroll_id = response.body._scroll_id;\n    let stop = false;\n\n    const clear = async () => {\n      stop = true;\n      await this[kClient].clearScroll({\n        body: {\n          scroll_id\n        }\n      }, {\n        ignore: [400],\n        ...options\n      });\n    };\n\n    while (response.body.hits && response.body.hits.hits.length > 0) {\n      // scroll id is always present in the response, but it might\n      // change over time based on the number of shards\n      scroll_id = response.body._scroll_id;\n      response.clear = clear;\n      addDocumentsGetter(response);\n      yield response;\n\n      if (stop === true) {\n        break;\n      }\n\n      for (let i = 0; i <= maxRetries; i++) {\n        response = await this[kClient].scroll({\n          scroll: querystring.scroll,\n          rest_total_hits_as_int: querystring.rest_total_hits_as_int || querystring.restTotalHitsAsInt,\n          body: {\n            scroll_id\n          }\n        }, options);\n        if (response.statusCode !== 429) break;\n        await sleep(wait);\n      }\n\n      if (response.statusCode === 429) {\n        throw new ResponseError(response);\n      }\n    }\n\n    if (stop === false) {\n      await clear();\n    }\n  }\n  /**\r\n   * Runs a scroll search operation. This function returns an async iterator, allowing\r\n   * the user to use a for await loop to get all the documents of a given search.\r\n   * ```js\r\n   * for await (const document of client.helpers.scrollSearch({ params })) {\r\n   *   console.log(document)\r\n   * }\r\n   * ```\r\n   * Each document is what you will find by running a scrollSearch and iterating on the hits array.\r\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\r\n   * as it will only need the documents source.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {iterator} the async iterator\r\n   */\n\n\n  async *scrollDocuments(params, options) {\n    appendFilterPath('hits.hits._source', params, true);\n\n    for await (const {\n      documents\n    } of this.scrollSearch(params, options)) {\n      for (const document of documents) {\n        yield document;\n      }\n    }\n  }\n  /**\r\n   * Creates a msearch helper instance. Once you configure it, you can use the provided\r\n   * `search` method to add new searches in the queue.\r\n   * @param {object} options - The configuration of the msearch operations.\r\n   * @param {object} reqOptions - The client optional configuration for this request.\r\n   * @return {object} The possible operations to run.\r\n   */\n\n\n  msearch(options = {}, reqOptions = {}) {\n    const client = this[kClient];\n    const {\n      operations = 5,\n      concurrency = 5,\n      flushInterval = 500,\n      retries = this.maxRetries,\n      wait = 5000,\n      ...msearchOptions\n    } = options;\n    let stopReading = false;\n    let stopError = null;\n    let timeoutRef = null;\n    const operationsStream = new Readable({\n      objectMode: true,\n\n      read(size) {}\n\n    });\n    const p = iterate();\n    const helper = {\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n\n      stop(error = null) {\n        if (stopReading === true) return;\n        stopReading = true;\n        stopError = error;\n        operationsStream.push(null);\n      },\n\n      // TODO: support abort a single search?\n      // NOTE: the validation checks are synchronous and the callback/promise will\n      //       be resolved in the same tick. We might want to fix this in the future.\n      search(header, body, callback) {\n        if (stopReading === true) {\n          const error = stopError === null ? new ConfigurationError('The msearch processor has been stopped') : stopError;\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\n          const error = new ConfigurationError('The header should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\n          const error = new ConfigurationError('The body should be an object');\n          return callback ? callback(error, {}) : Promise.reject(error);\n        }\n\n        let promise = null;\n\n        if (callback === undefined) {\n          let onFulfilled = null;\n          let onRejected = null;\n          promise = new Promise((resolve, reject) => {\n            onFulfilled = resolve;\n            onRejected = reject;\n          });\n\n          callback = function callback(err, result) {\n            err ? onRejected(err) : onFulfilled(result);\n          };\n        }\n\n        operationsStream.push([header, body, callback]);\n\n        if (promise !== null) {\n          return promise;\n        }\n      }\n\n    };\n    return helper;\n\n    async function iterate() {\n      const {\n        semaphore,\n        finish\n      } = buildSemaphore();\n      const msearchBody = [];\n      const callbacks = [];\n      let loadedOperations = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n\n      for await (const operation of operationsStream) {\n        timeoutRef.refresh();\n        loadedOperations += 1;\n        msearchBody.push(operation[0], operation[1]);\n        callbacks.push(operation[2]);\n\n        if (loadedOperations >= operations) {\n          const send = await semaphore();\n          send(msearchBody.slice(), callbacks.slice());\n          msearchBody.length = 0;\n          callbacks.length = 0;\n          loadedOperations = 0;\n        }\n      }\n\n      clearTimeout(timeoutRef); // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n\n      if (loadedOperations > 0) {\n        const send = await semaphore();\n        send(msearchBody, callbacks);\n      }\n\n      await finish();\n\n      if (stopError !== null) {\n        throw stopError;\n      }\n\n      async function onFlushTimeout() {\n        if (loadedOperations === 0) return;\n        const msearchBodyCopy = msearchBody.slice();\n        const callbacksCopy = callbacks.slice();\n        msearchBody.length = 0;\n        callbacks.length = 0;\n        loadedOperations = 0;\n\n        try {\n          const send = await semaphore();\n          send(msearchBodyCopy, callbacksCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.stop(err);\n        }\n      }\n    } // This function builds a semaphore using the concurrency\n    // options of the msearch helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual msearch request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running.\n\n\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let running = 0;\n      return {\n        semaphore,\n        finish\n      };\n\n      function finish() {\n        return new Promise((resolve, reject) => {\n          if (running === 0) {\n            resolve();\n          } else {\n            resolveFinish = resolve;\n          }\n        });\n      }\n\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise((resolve, reject) => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n\n      function send(msearchBody, callbacks) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n\n        msearchOperation(msearchBody, callbacks, () => {\n          running -= 1;\n\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            resolveFinish();\n          }\n        });\n      }\n    }\n\n    function msearchOperation(msearchBody, callbacks, done) {\n      let retryCount = retries; // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n\n      tryMsearch(msearchBody, callbacks, retrySearch);\n\n      function retrySearch(msearchBody, callbacks) {\n        if (msearchBody.length > 0 && retryCount > 0) {\n          retryCount -= 1;\n          setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch);\n          return;\n        }\n\n        done();\n      } // This function never returns an error, if the msearch operation fails,\n      // the error is dispatched to all search executors.\n\n\n      function tryMsearch(msearchBody, callbacks, done) {\n        client.msearch(Object.assign({}, msearchOptions, {\n          body: msearchBody\n        }), reqOptions, (err, results) => {\n          const retryBody = [];\n          const retryCallbacks = [];\n\n          if (err) {\n            addDocumentsGetter(results);\n\n            for (const callback of callbacks) {\n              callback(err, results);\n            }\n\n            return done(retryBody, retryCallbacks);\n          }\n\n          const {\n            responses\n          } = results.body;\n\n          for (let i = 0, len = responses.length; i < len; i++) {\n            const response = responses[i];\n\n            if (response.status === 429 && retryCount > 0) {\n              retryBody.push(msearchBody[i * 2]);\n              retryBody.push(msearchBody[i * 2 + 1]);\n              retryCallbacks.push(callbacks[i]);\n              continue;\n            }\n\n            const result = { ...results,\n              body: response\n            };\n            addDocumentsGetter(result);\n\n            if (response.status >= 400) {\n              callbacks[i](new ResponseError(result), result);\n            } else {\n              callbacks[i](null, result);\n            }\n          }\n\n          done(retryBody, retryCallbacks);\n        });\n      }\n    }\n  }\n  /**\r\n   * Creates a bulk helper instance. Once you configure it, you can pick which operation\r\n   * to execute with the given dataset, index, create, update, and delete.\r\n   * @param {object} options - The configuration of the bulk operation.\r\n   * @param {object} reqOptions - The client optional configuration for this request.\r\n   * @return {object} The possible operations to run with the datasource.\r\n   */\n\n\n  bulk(options, reqOptions = {}) {\n    const client = this[kClient];\n    const {\n      serializer\n    } = client;\n\n    if (this[kMetaHeader] !== null) {\n      reqOptions.headers = reqOptions.headers || {};\n      reqOptions.headers['x-elastic-client-meta'] = this[kMetaHeader] + ',h=bp';\n    }\n\n    const {\n      datasource,\n      onDocument,\n      flushBytes = 5000000,\n      flushInterval = 30000,\n      concurrency = 5,\n      retries = this.maxRetries,\n      wait = 5000,\n      onDrop = noop,\n      refreshOnCompletion = false,\n      ...bulkOptions\n    } = options;\n\n    if (datasource === undefined) {\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'));\n    }\n\n    if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || typeof datasource.pipe === 'function' || datasource[Symbol.asyncIterator])) {\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'));\n    }\n\n    if (onDocument === undefined) {\n      return Promise.reject(new ConfigurationError('bulk helper: the onDocument callback is required'));\n    }\n\n    let shouldAbort = false;\n    let timeoutRef = null;\n    const stats = {\n      total: 0,\n      failed: 0,\n      retry: 0,\n      successful: 0,\n      time: 0,\n      bytes: 0,\n      aborted: false\n    };\n    const p = iterate();\n    const helper = {\n      then(onFulfilled, onRejected) {\n        return p.then(onFulfilled, onRejected);\n      },\n\n      catch(onRejected) {\n        return p.catch(onRejected);\n      },\n\n      abort() {\n        clearTimeout(timeoutRef);\n        shouldAbort = true;\n        stats.aborted = true;\n        return this;\n      }\n\n    };\n    return helper;\n    /**\r\n     * Function that iterates over the given datasource and start a bulk operation as soon\r\n     * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\r\n     * model at this maximum capacity, as it will collect the next body to send while there is\r\n     * a running http call. In this way, the CPU time will be used carefully.\r\n     * The objects will be serialized right away, to approximate the byte length of the body.\r\n     * It creates an array of strings instead of a ndjson string because the bulkOperation\r\n     * will navigate the body for matching failed operations with the original document.\r\n     */\n\n    async function iterate() {\n      const {\n        semaphore,\n        finish\n      } = buildSemaphore();\n      const startTime = Date.now();\n      const bulkBody = [];\n      let actionBody = '';\n      let payloadBody = '';\n      let chunkBytes = 0;\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval);\n\n      for await (const chunk of datasource) {\n        if (shouldAbort === true) break;\n        timeoutRef.refresh();\n        const action = onDocument(chunk);\n        const operation = Array.isArray(action) ? Object.keys(action[0])[0] : Object.keys(action)[0];\n\n        if (operation === 'index' || operation === 'create') {\n          actionBody = serializer.serialize(action);\n          payloadBody = typeof chunk === 'string' ? chunk : serializer.serialize(chunk);\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'update') {\n          actionBody = serializer.serialize(action[0]);\n          payloadBody = typeof chunk === 'string' ? `{\"doc\":${chunk}}` : serializer.serialize({\n            doc: chunk,\n            ...action[1]\n          });\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n          bulkBody.push(actionBody, payloadBody);\n        } else if (operation === 'delete') {\n          actionBody = serializer.serialize(action);\n          chunkBytes += Buffer.byteLength(actionBody);\n          bulkBody.push(actionBody);\n        } else {\n          clearTimeout(timeoutRef);\n          throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);\n        }\n\n        if (chunkBytes >= flushBytes) {\n          stats.bytes += chunkBytes;\n          const send = await semaphore();\n          send(bulkBody.slice());\n          bulkBody.length = 0;\n          chunkBytes = 0;\n        }\n      }\n\n      clearTimeout(timeoutRef); // In some cases the previos http call does not have finished,\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\n\n      if (shouldAbort === false && chunkBytes > 0) {\n        const send = await semaphore();\n        stats.bytes += chunkBytes;\n        send(bulkBody);\n      }\n\n      await finish();\n\n      if (refreshOnCompletion) {\n        await client.indices.refresh({\n          index: typeof refreshOnCompletion === 'string' ? refreshOnCompletion : '_all'\n        }, reqOptions);\n      }\n\n      stats.time = Date.now() - startTime;\n      stats.total = stats.successful + stats.failed;\n      return stats;\n\n      async function onFlushTimeout() {\n        if (chunkBytes === 0) return;\n        stats.bytes += chunkBytes;\n        const bulkBodyCopy = bulkBody.slice();\n        bulkBody.length = 0;\n        chunkBytes = 0;\n\n        try {\n          const send = await semaphore();\n          send(bulkBodyCopy);\n        } catch (err) {\n          /* istanbul ignore next */\n          helper.abort();\n        }\n      }\n    } // This function builds a semaphore using the concurrency\n    // options of the bulk helper. It is used inside the iterator\n    // to guarantee that no more than the number of operations\n    // allowed to run at the same time are executed.\n    // It returns a semaphore function which resolves in the next tick\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\n    // a promise that resolves as soon as one of the running request has finshed.\n    // The semaphore function resolves a send function, which will be used\n    // to send the actual bulk request.\n    // It also returns a finish function, which returns a promise that is resolved\n    // when there are no longer request running. It rejects an error if one\n    // of the request has failed for some reason.\n\n\n    function buildSemaphore() {\n      let resolveSemaphore = null;\n      let resolveFinish = null;\n      let rejectFinish = null;\n      let error = null;\n      let running = 0;\n      return {\n        semaphore,\n        finish\n      };\n\n      function finish() {\n        return new Promise((resolve, reject) => {\n          if (running === 0) {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          } else {\n            resolveFinish = resolve;\n            rejectFinish = reject;\n          }\n        });\n      }\n\n      function semaphore() {\n        if (running < concurrency) {\n          running += 1;\n          return pImmediate(send);\n        } else {\n          return new Promise((resolve, reject) => {\n            resolveSemaphore = resolve;\n          });\n        }\n      }\n\n      function send(bulkBody) {\n        /* istanbul ignore if */\n        if (running > concurrency) {\n          throw new Error('Max concurrency reached');\n        }\n\n        bulkOperation(bulkBody, err => {\n          running -= 1;\n\n          if (err) {\n            shouldAbort = true;\n            error = err;\n          }\n\n          if (resolveSemaphore) {\n            running += 1;\n            resolveSemaphore(send);\n            resolveSemaphore = null;\n          } else if (resolveFinish && running === 0) {\n            if (error) {\n              rejectFinish(error);\n            } else {\n              resolveFinish();\n            }\n          }\n        });\n      }\n    }\n\n    function bulkOperation(bulkBody, callback) {\n      let retryCount = retries;\n      let isRetrying = false; // Instead of going full on async-await, which would make the code easier to read,\n      // we have decided to use callback style instead.\n      // This because every time we use async await, V8 will create multiple promises\n      // behind the scenes, making the code slightly slower.\n\n      tryBulk(bulkBody, retryDocuments);\n\n      function retryDocuments(err, bulkBody) {\n        if (err) return callback(err);\n        if (shouldAbort === true) return callback();\n\n        if (bulkBody.length > 0) {\n          if (retryCount > 0) {\n            isRetrying = true;\n            retryCount -= 1;\n            stats.retry += bulkBody.length;\n            setTimeout(tryBulk, wait, bulkBody, retryDocuments);\n            return;\n          }\n\n          for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\n            const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0];\n            onDrop({\n              status: 429,\n              error: null,\n              operation: serializer.deserialize(bulkBody[i]),\n              document: operation !== 'delete' ? serializer.deserialize(bulkBody[i + 1])\n              /* istanbul ignore next */\n              : null,\n              retried: isRetrying\n            });\n            stats.failed += 1;\n          }\n        }\n\n        callback();\n      }\n\n      function tryBulk(bulkBody, callback) {\n        if (shouldAbort === true) return callback(null, []);\n        client.bulk(Object.assign({}, bulkOptions, {\n          body: bulkBody\n        }), reqOptions, (err, {\n          body\n        }) => {\n          if (err) return callback(err, null);\n\n          if (body.errors === false) {\n            stats.successful += body.items.length;\n            return callback(null, []);\n          }\n\n          const retry = [];\n          const {\n            items\n          } = body;\n\n          for (let i = 0, len = items.length; i < len; i++) {\n            const action = items[i];\n            const operation = Object.keys(action)[0];\n            const {\n              status\n            } = action[operation];\n            const indexSlice = operation !== 'delete' ? i * 2 : i;\n\n            if (status >= 400) {\n              // 429 is the only staus code where we might want to retry\n              // a document, because it was not an error in the document itself,\n              // but the ES node were handling too many operations.\n              if (status === 429) {\n                retry.push(bulkBody[indexSlice]);\n                /* istanbul ignore next */\n\n                if (operation !== 'delete') {\n                  retry.push(bulkBody[indexSlice + 1]);\n                }\n              } else {\n                onDrop({\n                  status: status,\n                  error: action[operation].error,\n                  operation: serializer.deserialize(bulkBody[indexSlice]),\n                  document: operation !== 'delete' ? serializer.deserialize(bulkBody[indexSlice + 1]) : null,\n                  retried: isRetrying\n                });\n                stats.failed += 1;\n              }\n            } else {\n              stats.successful += 1;\n            }\n          }\n\n          callback(null, retry);\n        });\n      }\n    }\n  }\n\n} // Using a getter will improve the overall performances of the code,\n// as we will reed the documents only if needed.\n\n\nfunction addDocumentsGetter(result) {\n  Object.defineProperty(result, 'documents', {\n    get() {\n      if (this.body.hits && this.body.hits.hits) {\n        return this.body.hits.hits.map(d => d._source);\n      }\n\n      return [];\n    }\n\n  });\n}\n\nfunction appendFilterPath(filter, params, force) {\n  if (params.filter_path !== undefined) {\n    params.filter_path += ',' + filter;\n  } else if (params.filterPath !== undefined) {\n    params.filterPath += ',' + filter;\n  } else if (force === true) {\n    params.filter_path = filter;\n  }\n}\n\nmodule.exports = Helpers;","map":{"version":3,"sources":["C:/Users/vince/peer/project/app_react/src/node_modules/@elastic/elasticsearch/lib/Helpers.js"],"names":["Readable","require","promisify","ResponseError","ConfigurationError","pImmediate","setImmediate","sleep","setTimeout","kClient","Symbol","kMetaHeader","noop","Helpers","constructor","opts","client","metaHeader","maxRetries","search","params","options","appendFilterPath","body","hits","map","d","_source","scrollSearch","headers","wait","Array","isArray","ignore","push","scroll","method","index","querystring","response","i","statusCode","scroll_id","_scroll_id","stop","clear","clearScroll","length","addDocumentsGetter","rest_total_hits_as_int","restTotalHitsAsInt","scrollDocuments","documents","document","msearch","reqOptions","operations","concurrency","flushInterval","retries","msearchOptions","stopReading","stopError","timeoutRef","operationsStream","objectMode","read","size","p","iterate","helper","then","onFulfilled","onRejected","catch","error","header","callback","Promise","reject","promise","undefined","resolve","err","result","semaphore","finish","buildSemaphore","msearchBody","callbacks","loadedOperations","onFlushTimeout","operation","refresh","send","slice","clearTimeout","msearchBodyCopy","callbacksCopy","resolveSemaphore","resolveFinish","running","Error","msearchOperation","done","retryCount","tryMsearch","retrySearch","Object","assign","results","retryBody","retryCallbacks","responses","len","status","bulk","serializer","datasource","onDocument","flushBytes","onDrop","refreshOnCompletion","bulkOptions","Buffer","isBuffer","pipe","asyncIterator","shouldAbort","stats","total","failed","retry","successful","time","bytes","aborted","abort","startTime","Date","now","bulkBody","actionBody","payloadBody","chunkBytes","chunk","action","keys","serialize","byteLength","doc","indices","bulkBodyCopy","rejectFinish","bulkOperation","isRetrying","tryBulk","retryDocuments","deserialize","retried","errors","items","indexSlice","defineProperty","get","filter","force","filter_path","filterPath","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\n'use strict'\r\n\r\n/* eslint camelcase: 0 */\r\n\r\nconst { Readable } = require('stream')\r\nconst { promisify } = require('util')\r\nconst { ResponseError, ConfigurationError } = require('./errors')\r\n\r\nconst pImmediate = promisify(setImmediate)\r\nconst sleep = promisify(setTimeout)\r\nconst kClient = Symbol('elasticsearch-client')\r\nconst kMetaHeader = Symbol('meta header')\r\n/* istanbul ignore next */\r\nconst noop = () => {}\r\n\r\nclass Helpers {\r\n  constructor (opts) {\r\n    this[kClient] = opts.client\r\n    this[kMetaHeader] = opts.metaHeader\r\n    this.maxRetries = opts.maxRetries\r\n  }\r\n\r\n  /**\r\n   * Runs a search operation. The only difference between client.search and this utility,\r\n   * is that we are only returning the hits to the user and not the full ES response.\r\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\r\n   * as it will only need the documents source.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {array} The documents that matched the request.\r\n   */\r\n  async search (params, options) {\r\n    appendFilterPath('hits.hits._source', params, true)\r\n    const { body } = await this[kClient].search(params, options)\r\n    if (body.hits && body.hits.hits) {\r\n      return body.hits.hits.map(d => d._source)\r\n    }\r\n    return []\r\n  }\r\n\r\n  /**\r\n   * Runs a scroll search operation. This function returns an async iterator, allowing\r\n   * the user to use a for await loop to get all the results of a given search.\r\n   * ```js\r\n   * for await (const result of client.helpers.scrollSearch({ params })) {\r\n   *   console.log(result)\r\n   * }\r\n   * ```\r\n   * Each result represents the entire body of a single scroll search request,\r\n   * if you just need to scroll the results, use scrollDocuments.\r\n   * This function handles automatically retries on 429 status code.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {iterator} the async iterator\r\n   */\r\n  async * scrollSearch (params, options = {}) {\r\n    if (this[kMetaHeader] !== null) {\r\n      options.headers = options.headers || {}\r\n      options.headers['x-elastic-client-meta'] = this[kMetaHeader] + ',h=s'\r\n    }\r\n    // TODO: study scroll search slices\r\n    const wait = options.wait || 5000\r\n    const maxRetries = options.maxRetries || this.maxRetries\r\n    if (Array.isArray(options.ignore)) {\r\n      options.ignore.push(429)\r\n    } else {\r\n      options.ignore = [429]\r\n    }\r\n    params.scroll = params.scroll || '1m'\r\n    appendFilterPath('_scroll_id', params, false)\r\n    const { method, body, index, ...querystring } = params\r\n\r\n    let response = null\r\n    for (let i = 0; i <= maxRetries; i++) {\r\n      response = await this[kClient].search(params, options)\r\n      if (response.statusCode !== 429) break\r\n      await sleep(wait)\r\n    }\r\n    if (response.statusCode === 429) {\r\n      throw new ResponseError(response)\r\n    }\r\n\r\n    let scroll_id = response.body._scroll_id\r\n    let stop = false\r\n    const clear = async () => {\r\n      stop = true\r\n      await this[kClient].clearScroll(\r\n        { body: { scroll_id } },\r\n        { ignore: [400], ...options }\r\n      )\r\n    }\r\n\r\n    while (response.body.hits && response.body.hits.hits.length > 0) {\r\n      // scroll id is always present in the response, but it might\r\n      // change over time based on the number of shards\r\n      scroll_id = response.body._scroll_id\r\n      response.clear = clear\r\n      addDocumentsGetter(response)\r\n\r\n      yield response\r\n\r\n      if (stop === true) {\r\n        break\r\n      }\r\n\r\n      for (let i = 0; i <= maxRetries; i++) {\r\n        response = await this[kClient].scroll({\r\n          scroll: querystring.scroll,\r\n          rest_total_hits_as_int: querystring.rest_total_hits_as_int || querystring.restTotalHitsAsInt,\r\n          body: { scroll_id }\r\n        }, options)\r\n        if (response.statusCode !== 429) break\r\n        await sleep(wait)\r\n      }\r\n      if (response.statusCode === 429) {\r\n        throw new ResponseError(response)\r\n      }\r\n    }\r\n\r\n    if (stop === false) {\r\n      await clear()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Runs a scroll search operation. This function returns an async iterator, allowing\r\n   * the user to use a for await loop to get all the documents of a given search.\r\n   * ```js\r\n   * for await (const document of client.helpers.scrollSearch({ params })) {\r\n   *   console.log(document)\r\n   * }\r\n   * ```\r\n   * Each document is what you will find by running a scrollSearch and iterating on the hits array.\r\n   * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\r\n   * as it will only need the documents source.\r\n   * @param {object} params - The Elasticsearch's search parameters.\r\n   * @param {object} options - The client optional configuration for this request.\r\n   * @return {iterator} the async iterator\r\n   */\r\n  async * scrollDocuments (params, options) {\r\n    appendFilterPath('hits.hits._source', params, true)\r\n    for await (const { documents } of this.scrollSearch(params, options)) {\r\n      for (const document of documents) {\r\n        yield document\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a msearch helper instance. Once you configure it, you can use the provided\r\n   * `search` method to add new searches in the queue.\r\n   * @param {object} options - The configuration of the msearch operations.\r\n   * @param {object} reqOptions - The client optional configuration for this request.\r\n   * @return {object} The possible operations to run.\r\n   */\r\n  msearch (options = {}, reqOptions = {}) {\r\n    const client = this[kClient]\r\n    const {\r\n      operations = 5,\r\n      concurrency = 5,\r\n      flushInterval = 500,\r\n      retries = this.maxRetries,\r\n      wait = 5000,\r\n      ...msearchOptions\r\n    } = options\r\n\r\n    let stopReading = false\r\n    let stopError = null\r\n    let timeoutRef = null\r\n    const operationsStream = new Readable({\r\n      objectMode: true,\r\n      read (size) {}\r\n    })\r\n\r\n    const p = iterate()\r\n    const helper = {\r\n      then (onFulfilled, onRejected) {\r\n        return p.then(onFulfilled, onRejected)\r\n      },\r\n      catch (onRejected) {\r\n        return p.catch(onRejected)\r\n      },\r\n      stop (error = null) {\r\n        if (stopReading === true) return\r\n        stopReading = true\r\n        stopError = error\r\n        operationsStream.push(null)\r\n      },\r\n      // TODO: support abort a single search?\r\n      // NOTE: the validation checks are synchronous and the callback/promise will\r\n      //       be resolved in the same tick. We might want to fix this in the future.\r\n      search (header, body, callback) {\r\n        if (stopReading === true) {\r\n          const error = stopError === null\r\n            ? new ConfigurationError('The msearch processor has been stopped')\r\n            : stopError\r\n          return callback ? callback(error, {}) : Promise.reject(error)\r\n        }\r\n\r\n        if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\r\n          const error = new ConfigurationError('The header should be an object')\r\n          return callback ? callback(error, {}) : Promise.reject(error)\r\n        }\r\n\r\n        if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\r\n          const error = new ConfigurationError('The body should be an object')\r\n          return callback ? callback(error, {}) : Promise.reject(error)\r\n        }\r\n\r\n        let promise = null\r\n        if (callback === undefined) {\r\n          let onFulfilled = null\r\n          let onRejected = null\r\n          promise = new Promise((resolve, reject) => {\r\n            onFulfilled = resolve\r\n            onRejected = reject\r\n          })\r\n          callback = function callback (err, result) {\r\n            err ? onRejected(err) : onFulfilled(result)\r\n          }\r\n        }\r\n\r\n        operationsStream.push([header, body, callback])\r\n\r\n        if (promise !== null) {\r\n          return promise\r\n        }\r\n      }\r\n    }\r\n\r\n    return helper\r\n\r\n    async function iterate () {\r\n      const { semaphore, finish } = buildSemaphore()\r\n      const msearchBody = []\r\n      const callbacks = []\r\n      let loadedOperations = 0\r\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval)\r\n\r\n      for await (const operation of operationsStream) {\r\n        timeoutRef.refresh()\r\n        loadedOperations += 1\r\n        msearchBody.push(operation[0], operation[1])\r\n        callbacks.push(operation[2])\r\n        if (loadedOperations >= operations) {\r\n          const send = await semaphore()\r\n          send(msearchBody.slice(), callbacks.slice())\r\n          msearchBody.length = 0\r\n          callbacks.length = 0\r\n          loadedOperations = 0\r\n        }\r\n      }\r\n\r\n      clearTimeout(timeoutRef)\r\n      // In some cases the previos http call does not have finished,\r\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\r\n      if (loadedOperations > 0) {\r\n        const send = await semaphore()\r\n        send(msearchBody, callbacks)\r\n      }\r\n\r\n      await finish()\r\n\r\n      if (stopError !== null) {\r\n        throw stopError\r\n      }\r\n\r\n      async function onFlushTimeout () {\r\n        if (loadedOperations === 0) return\r\n        const msearchBodyCopy = msearchBody.slice()\r\n        const callbacksCopy = callbacks.slice()\r\n        msearchBody.length = 0\r\n        callbacks.length = 0\r\n        loadedOperations = 0\r\n        try {\r\n          const send = await semaphore()\r\n          send(msearchBodyCopy, callbacksCopy)\r\n        } catch (err) {\r\n          /* istanbul ignore next */\r\n          helper.stop(err)\r\n        }\r\n      }\r\n    }\r\n\r\n    // This function builds a semaphore using the concurrency\r\n    // options of the msearch helper. It is used inside the iterator\r\n    // to guarantee that no more than the number of operations\r\n    // allowed to run at the same time are executed.\r\n    // It returns a semaphore function which resolves in the next tick\r\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\r\n    // a promise that resolves as soon as one of the running request has finshed.\r\n    // The semaphore function resolves a send function, which will be used\r\n    // to send the actual msearch request.\r\n    // It also returns a finish function, which returns a promise that is resolved\r\n    // when there are no longer request running.\r\n    function buildSemaphore () {\r\n      let resolveSemaphore = null\r\n      let resolveFinish = null\r\n      let running = 0\r\n\r\n      return { semaphore, finish }\r\n\r\n      function finish () {\r\n        return new Promise((resolve, reject) => {\r\n          if (running === 0) {\r\n            resolve()\r\n          } else {\r\n            resolveFinish = resolve\r\n          }\r\n        })\r\n      }\r\n\r\n      function semaphore () {\r\n        if (running < concurrency) {\r\n          running += 1\r\n          return pImmediate(send)\r\n        } else {\r\n          return new Promise((resolve, reject) => {\r\n            resolveSemaphore = resolve\r\n          })\r\n        }\r\n      }\r\n\r\n      function send (msearchBody, callbacks) {\r\n        /* istanbul ignore if */\r\n        if (running > concurrency) {\r\n          throw new Error('Max concurrency reached')\r\n        }\r\n        msearchOperation(msearchBody, callbacks, () => {\r\n          running -= 1\r\n          if (resolveSemaphore) {\r\n            running += 1\r\n            resolveSemaphore(send)\r\n            resolveSemaphore = null\r\n          } else if (resolveFinish && running === 0) {\r\n            resolveFinish()\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    function msearchOperation (msearchBody, callbacks, done) {\r\n      let retryCount = retries\r\n\r\n      // Instead of going full on async-await, which would make the code easier to read,\r\n      // we have decided to use callback style instead.\r\n      // This because every time we use async await, V8 will create multiple promises\r\n      // behind the scenes, making the code slightly slower.\r\n      tryMsearch(msearchBody, callbacks, retrySearch)\r\n      function retrySearch (msearchBody, callbacks) {\r\n        if (msearchBody.length > 0 && retryCount > 0) {\r\n          retryCount -= 1\r\n          setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch)\r\n          return\r\n        }\r\n\r\n        done()\r\n      }\r\n\r\n      // This function never returns an error, if the msearch operation fails,\r\n      // the error is dispatched to all search executors.\r\n      function tryMsearch (msearchBody, callbacks, done) {\r\n        client.msearch(Object.assign({}, msearchOptions, { body: msearchBody }), reqOptions, (err, results) => {\r\n          const retryBody = []\r\n          const retryCallbacks = []\r\n          if (err) {\r\n            addDocumentsGetter(results)\r\n            for (const callback of callbacks) {\r\n              callback(err, results)\r\n            }\r\n            return done(retryBody, retryCallbacks)\r\n          }\r\n          const { responses } = results.body\r\n          for (let i = 0, len = responses.length; i < len; i++) {\r\n            const response = responses[i]\r\n            if (response.status === 429 && retryCount > 0) {\r\n              retryBody.push(msearchBody[i * 2])\r\n              retryBody.push(msearchBody[(i * 2) + 1])\r\n              retryCallbacks.push(callbacks[i])\r\n              continue\r\n            }\r\n            const result = { ...results, body: response }\r\n            addDocumentsGetter(result)\r\n            if (response.status >= 400) {\r\n              callbacks[i](new ResponseError(result), result)\r\n            } else {\r\n              callbacks[i](null, result)\r\n            }\r\n          }\r\n          done(retryBody, retryCallbacks)\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a bulk helper instance. Once you configure it, you can pick which operation\r\n   * to execute with the given dataset, index, create, update, and delete.\r\n   * @param {object} options - The configuration of the bulk operation.\r\n   * @param {object} reqOptions - The client optional configuration for this request.\r\n   * @return {object} The possible operations to run with the datasource.\r\n   */\r\n  bulk (options, reqOptions = {}) {\r\n    const client = this[kClient]\r\n    const { serializer } = client\r\n    if (this[kMetaHeader] !== null) {\r\n      reqOptions.headers = reqOptions.headers || {}\r\n      reqOptions.headers['x-elastic-client-meta'] = this[kMetaHeader] + ',h=bp'\r\n    }\r\n    const {\r\n      datasource,\r\n      onDocument,\r\n      flushBytes = 5000000,\r\n      flushInterval = 30000,\r\n      concurrency = 5,\r\n      retries = this.maxRetries,\r\n      wait = 5000,\r\n      onDrop = noop,\r\n      refreshOnCompletion = false,\r\n      ...bulkOptions\r\n    } = options\r\n\r\n    if (datasource === undefined) {\r\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'))\r\n    }\r\n    if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || typeof datasource.pipe === 'function' || datasource[Symbol.asyncIterator])) {\r\n      return Promise.reject(new ConfigurationError('bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'))\r\n    }\r\n    if (onDocument === undefined) {\r\n      return Promise.reject(new ConfigurationError('bulk helper: the onDocument callback is required'))\r\n    }\r\n\r\n    let shouldAbort = false\r\n    let timeoutRef = null\r\n    const stats = {\r\n      total: 0,\r\n      failed: 0,\r\n      retry: 0,\r\n      successful: 0,\r\n      time: 0,\r\n      bytes: 0,\r\n      aborted: false\r\n    }\r\n\r\n    const p = iterate()\r\n    const helper = {\r\n      then (onFulfilled, onRejected) {\r\n        return p.then(onFulfilled, onRejected)\r\n      },\r\n      catch (onRejected) {\r\n        return p.catch(onRejected)\r\n      },\r\n      abort () {\r\n        clearTimeout(timeoutRef)\r\n        shouldAbort = true\r\n        stats.aborted = true\r\n        return this\r\n      }\r\n    }\r\n\r\n    return helper\r\n\r\n    /**\r\n     * Function that iterates over the given datasource and start a bulk operation as soon\r\n     * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\r\n     * model at this maximum capacity, as it will collect the next body to send while there is\r\n     * a running http call. In this way, the CPU time will be used carefully.\r\n     * The objects will be serialized right away, to approximate the byte length of the body.\r\n     * It creates an array of strings instead of a ndjson string because the bulkOperation\r\n     * will navigate the body for matching failed operations with the original document.\r\n     */\r\n    async function iterate () {\r\n      const { semaphore, finish } = buildSemaphore()\r\n      const startTime = Date.now()\r\n      const bulkBody = []\r\n      let actionBody = ''\r\n      let payloadBody = ''\r\n      let chunkBytes = 0\r\n      timeoutRef = setTimeout(onFlushTimeout, flushInterval)\r\n\r\n      for await (const chunk of datasource) {\r\n        if (shouldAbort === true) break\r\n        timeoutRef.refresh()\r\n        const action = onDocument(chunk)\r\n        const operation = Array.isArray(action)\r\n          ? Object.keys(action[0])[0]\r\n          : Object.keys(action)[0]\r\n        if (operation === 'index' || operation === 'create') {\r\n          actionBody = serializer.serialize(action)\r\n          payloadBody = typeof chunk === 'string' ? chunk : serializer.serialize(chunk)\r\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody)\r\n          bulkBody.push(actionBody, payloadBody)\r\n        } else if (operation === 'update') {\r\n          actionBody = serializer.serialize(action[0])\r\n          payloadBody = typeof chunk === 'string'\r\n            ? `{\"doc\":${chunk}}`\r\n            : serializer.serialize({ doc: chunk, ...action[1] })\r\n          chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody)\r\n          bulkBody.push(actionBody, payloadBody)\r\n        } else if (operation === 'delete') {\r\n          actionBody = serializer.serialize(action)\r\n          chunkBytes += Buffer.byteLength(actionBody)\r\n          bulkBody.push(actionBody)\r\n        } else {\r\n          clearTimeout(timeoutRef)\r\n          throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`)\r\n        }\r\n\r\n        if (chunkBytes >= flushBytes) {\r\n          stats.bytes += chunkBytes\r\n          const send = await semaphore()\r\n          send(bulkBody.slice())\r\n          bulkBody.length = 0\r\n          chunkBytes = 0\r\n        }\r\n      }\r\n\r\n      clearTimeout(timeoutRef)\r\n      // In some cases the previos http call does not have finished,\r\n      // or we didn't reach the flush bytes threshold, so we force one last operation.\r\n      if (shouldAbort === false && chunkBytes > 0) {\r\n        const send = await semaphore()\r\n        stats.bytes += chunkBytes\r\n        send(bulkBody)\r\n      }\r\n\r\n      await finish()\r\n\r\n      if (refreshOnCompletion) {\r\n        await client.indices.refresh({\r\n          index: typeof refreshOnCompletion === 'string'\r\n            ? refreshOnCompletion\r\n            : '_all'\r\n        }, reqOptions)\r\n      }\r\n\r\n      stats.time = Date.now() - startTime\r\n      stats.total = stats.successful + stats.failed\r\n\r\n      return stats\r\n\r\n      async function onFlushTimeout () {\r\n        if (chunkBytes === 0) return\r\n        stats.bytes += chunkBytes\r\n        const bulkBodyCopy = bulkBody.slice()\r\n        bulkBody.length = 0\r\n        chunkBytes = 0\r\n        try {\r\n          const send = await semaphore()\r\n          send(bulkBodyCopy)\r\n        } catch (err) {\r\n          /* istanbul ignore next */\r\n          helper.abort()\r\n        }\r\n      }\r\n    }\r\n\r\n    // This function builds a semaphore using the concurrency\r\n    // options of the bulk helper. It is used inside the iterator\r\n    // to guarantee that no more than the number of operations\r\n    // allowed to run at the same time are executed.\r\n    // It returns a semaphore function which resolves in the next tick\r\n    // if we didn't reach the maximim concurrency yet, otherwise it returns\r\n    // a promise that resolves as soon as one of the running request has finshed.\r\n    // The semaphore function resolves a send function, which will be used\r\n    // to send the actual bulk request.\r\n    // It also returns a finish function, which returns a promise that is resolved\r\n    // when there are no longer request running. It rejects an error if one\r\n    // of the request has failed for some reason.\r\n    function buildSemaphore () {\r\n      let resolveSemaphore = null\r\n      let resolveFinish = null\r\n      let rejectFinish = null\r\n      let error = null\r\n      let running = 0\r\n\r\n      return { semaphore, finish }\r\n\r\n      function finish () {\r\n        return new Promise((resolve, reject) => {\r\n          if (running === 0) {\r\n            if (error) {\r\n              reject(error)\r\n            } else {\r\n              resolve()\r\n            }\r\n          } else {\r\n            resolveFinish = resolve\r\n            rejectFinish = reject\r\n          }\r\n        })\r\n      }\r\n\r\n      function semaphore () {\r\n        if (running < concurrency) {\r\n          running += 1\r\n          return pImmediate(send)\r\n        } else {\r\n          return new Promise((resolve, reject) => {\r\n            resolveSemaphore = resolve\r\n          })\r\n        }\r\n      }\r\n\r\n      function send (bulkBody) {\r\n        /* istanbul ignore if */\r\n        if (running > concurrency) {\r\n          throw new Error('Max concurrency reached')\r\n        }\r\n        bulkOperation(bulkBody, err => {\r\n          running -= 1\r\n          if (err) {\r\n            shouldAbort = true\r\n            error = err\r\n          }\r\n          if (resolveSemaphore) {\r\n            running += 1\r\n            resolveSemaphore(send)\r\n            resolveSemaphore = null\r\n          } else if (resolveFinish && running === 0) {\r\n            if (error) {\r\n              rejectFinish(error)\r\n            } else {\r\n              resolveFinish()\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    function bulkOperation (bulkBody, callback) {\r\n      let retryCount = retries\r\n      let isRetrying = false\r\n\r\n      // Instead of going full on async-await, which would make the code easier to read,\r\n      // we have decided to use callback style instead.\r\n      // This because every time we use async await, V8 will create multiple promises\r\n      // behind the scenes, making the code slightly slower.\r\n      tryBulk(bulkBody, retryDocuments)\r\n      function retryDocuments (err, bulkBody) {\r\n        if (err) return callback(err)\r\n        if (shouldAbort === true) return callback()\r\n\r\n        if (bulkBody.length > 0) {\r\n          if (retryCount > 0) {\r\n            isRetrying = true\r\n            retryCount -= 1\r\n            stats.retry += bulkBody.length\r\n            setTimeout(tryBulk, wait, bulkBody, retryDocuments)\r\n            return\r\n          }\r\n          for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\r\n            const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0]\r\n            onDrop({\r\n              status: 429,\r\n              error: null,\r\n              operation: serializer.deserialize(bulkBody[i]),\r\n              document: operation !== 'delete'\r\n                ? serializer.deserialize(bulkBody[i + 1])\r\n                /* istanbul ignore next */\r\n                : null,\r\n              retried: isRetrying\r\n            })\r\n            stats.failed += 1\r\n          }\r\n        }\r\n        callback()\r\n      }\r\n\r\n      function tryBulk (bulkBody, callback) {\r\n        if (shouldAbort === true) return callback(null, [])\r\n        client.bulk(Object.assign({}, bulkOptions, { body: bulkBody }), reqOptions, (err, { body }) => {\r\n          if (err) return callback(err, null)\r\n          if (body.errors === false) {\r\n            stats.successful += body.items.length\r\n            return callback(null, [])\r\n          }\r\n          const retry = []\r\n          const { items } = body\r\n          for (let i = 0, len = items.length; i < len; i++) {\r\n            const action = items[i]\r\n            const operation = Object.keys(action)[0]\r\n            const { status } = action[operation]\r\n            const indexSlice = operation !== 'delete' ? i * 2 : i\r\n\r\n            if (status >= 400) {\r\n              // 429 is the only staus code where we might want to retry\r\n              // a document, because it was not an error in the document itself,\r\n              // but the ES node were handling too many operations.\r\n              if (status === 429) {\r\n                retry.push(bulkBody[indexSlice])\r\n                /* istanbul ignore next */\r\n                if (operation !== 'delete') {\r\n                  retry.push(bulkBody[indexSlice + 1])\r\n                }\r\n              } else {\r\n                onDrop({\r\n                  status: status,\r\n                  error: action[operation].error,\r\n                  operation: serializer.deserialize(bulkBody[indexSlice]),\r\n                  document: operation !== 'delete'\r\n                    ? serializer.deserialize(bulkBody[indexSlice + 1])\r\n                    : null,\r\n                  retried: isRetrying\r\n                })\r\n                stats.failed += 1\r\n              }\r\n            } else {\r\n              stats.successful += 1\r\n            }\r\n          }\r\n          callback(null, retry)\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Using a getter will improve the overall performances of the code,\r\n// as we will reed the documents only if needed.\r\nfunction addDocumentsGetter (result) {\r\n  Object.defineProperty(result, 'documents', {\r\n    get () {\r\n      if (this.body.hits && this.body.hits.hits) {\r\n        return this.body.hits.hits.map(d => d._source)\r\n      }\r\n      return []\r\n    }\r\n  })\r\n}\r\n\r\nfunction appendFilterPath (filter, params, force) {\r\n  if (params.filter_path !== undefined) {\r\n    params.filter_path += ',' + filter\r\n  } else if (params.filterPath !== undefined) {\r\n    params.filterPath += ',' + filter\r\n  } else if (force === true) {\r\n    params.filter_path = filter\r\n  }\r\n}\r\n\r\nmodule.exports = Helpers\r\n"]},"metadata":{},"sourceType":"module"}