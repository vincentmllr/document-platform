{"ast":null,"code":"/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n'use strict';\n\nconst {\n  URL\n} = require('url');\n\nconst debug = require('debug')('elasticsearch');\n\nconst Connection = require('../Connection');\n\nconst noop = () => {};\n\nclass BaseConnectionPool {\n  constructor(opts) {\n    // list of nodes and weights\n    this.connections = []; // how many nodes we have in our scheduler\n\n    this.size = this.connections.length;\n    this.Connection = opts.Connection;\n    this.emit = opts.emit || noop;\n    this.auth = opts.auth || null;\n    this._ssl = opts.ssl;\n    this._agent = opts.agent;\n    this._proxy = opts.proxy || null;\n  }\n\n  getConnection() {\n    throw new Error('getConnection must be implemented');\n  }\n\n  markAlive() {\n    return this;\n  }\n\n  markDead() {\n    return this;\n  }\n  /**\r\n   * Creates a new connection instance.\r\n   */\n\n\n  createConnection(opts) {\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    if (this.auth !== null) {\n      opts.auth = this.auth;\n    } else if (opts.url.username !== '' && opts.url.password !== '') {\n      opts.auth = {\n        username: decodeURIComponent(opts.url.username),\n        password: decodeURIComponent(opts.url.password)\n      };\n    }\n\n    if (opts.ssl == null) opts.ssl = this._ssl;\n    /* istanbul ignore else */\n\n    if (opts.agent == null) opts.agent = this._agent;\n    /* istanbul ignore else */\n\n    if (opts.proxy == null) opts.proxy = this._proxy;\n    const connection = new this.Connection(opts);\n\n    for (const conn of this.connections) {\n      if (conn.id === connection.id) {\n        throw new Error(`Connection with id '${connection.id}' is already present`);\n      }\n    }\n\n    return connection;\n  }\n  /**\r\n   * Adds a new connection to the pool.\r\n   *\r\n   * @param {object|string} host\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  addConnection(opts) {\n    if (Array.isArray(opts)) {\n      return opts.forEach(o => this.addConnection(o));\n    }\n\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    const connectionById = this.connections.find(c => c.id === opts.id);\n    const connectionByUrl = this.connections.find(c => c.id === opts.url.href);\n\n    if (connectionById || connectionByUrl) {\n      throw new Error(`Connection with id '${opts.id || opts.url.href}' is already present`);\n    }\n\n    this.update([...this.connections, opts]);\n    return this.connections[this.size - 1];\n  }\n  /**\r\n   * Removes a new connection to the pool.\r\n   *\r\n   * @param {object} connection\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  removeConnection(connection) {\n    debug('Removing connection', connection);\n    return this.update(this.connections.filter(c => c.id !== connection.id));\n  }\n  /**\r\n   * Empties the connection pool.\r\n   *\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  empty(callback) {\n    debug('Emptying the connection pool');\n    let openConnections = this.size;\n    this.connections.forEach(connection => {\n      connection.close(() => {\n        if (--openConnections === 0) {\n          this.connections = [];\n          this.size = this.connections.length;\n          callback();\n        }\n      });\n    });\n  }\n  /**\r\n   * Update the ConnectionPool with new connections.\r\n   *\r\n   * @param {array} array of connections\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  update(nodes) {\n    debug('Updating the connection pool');\n    const newConnections = [];\n    const oldConnections = [];\n\n    for (const node of nodes) {\n      // if we already have a given connection in the pool\n      // we mark it as alive and we do not close the connection\n      // to avoid socket issues\n      const connectionById = this.connections.find(c => c.id === node.id);\n      const connectionByUrl = this.connections.find(c => c.id === node.url.href);\n\n      if (connectionById) {\n        debug(`The connection with id '${node.id}' is already present`);\n        this.markAlive(connectionById);\n        newConnections.push(connectionById); // in case the user has passed a single url (or an array of urls),\n        // the connection id will be the full href; to avoid closing valid connections\n        // because are not present in the pool, we check also the node url,\n        // and if is already present we update its id with the ES provided one.\n      } else if (connectionByUrl) {\n        connectionByUrl.id = node.id;\n        this.markAlive(connectionByUrl);\n        newConnections.push(connectionByUrl);\n      } else {\n        newConnections.push(this.createConnection(node));\n      }\n    }\n\n    const ids = nodes.map(c => c.id); // remove all the dead connections and old connections\n\n    for (const connection of this.connections) {\n      if (ids.indexOf(connection.id) === -1) {\n        oldConnections.push(connection);\n      }\n    } // close old connections\n\n\n    oldConnections.forEach(connection => connection.close());\n    this.connections = newConnections;\n    this.size = this.connections.length;\n    return this;\n  }\n  /**\r\n   * Transforms the nodes objects to a host object.\r\n   *\r\n   * @param {object} nodes\r\n   * @returns {array} hosts\r\n   */\n\n\n  nodesToHost(nodes, protocol) {\n    const ids = Object.keys(nodes);\n    const hosts = [];\n\n    for (let i = 0, len = ids.length; i < len; i++) {\n      const node = nodes[ids[i]]; // If there is no protocol in\n      // the `publish_address` new URL will throw\n      // the publish_address can have two forms:\n      //   - ip:port\n      //   - hostname/ip:port\n      // if we encounter the second case, we should\n      // use the hostname instead of the ip\n\n      let address = node.http.publish_address;\n      const parts = address.split('/'); // the url is in the form of hostname/ip:port\n\n      if (parts.length > 1) {\n        const hostname = parts[0];\n        const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n        address = `${hostname}:${port}`;\n      }\n\n      address = address.slice(0, 4) === 'http'\n      /* istanbul ignore next */\n      ? address : `${protocol}//${address}`;\n      const roles = node.roles.reduce((acc, role) => {\n        acc[role] = true;\n        return acc;\n      }, {});\n      hosts.push({\n        url: new URL(address),\n        id: ids[i],\n        roles: Object.assign({\n          [Connection.roles.MASTER]: false,\n          [Connection.roles.DATA]: false,\n          [Connection.roles.INGEST]: false,\n          [Connection.roles.ML]: false\n        }, roles)\n      });\n    }\n\n    return hosts;\n  }\n  /**\r\n   * Transforms an url string to a host object\r\n   *\r\n   * @param {string} url\r\n   * @returns {object} host\r\n   */\n\n\n  urlToHost(url) {\n    return {\n      url: new URL(url)\n    };\n  }\n\n}\n\nmodule.exports = BaseConnectionPool;","map":{"version":3,"sources":["C:/Users/vince/peer/project/app_react/src/node_modules/@elastic/elasticsearch/lib/pool/BaseConnectionPool.js"],"names":["URL","require","debug","Connection","noop","BaseConnectionPool","constructor","opts","connections","size","length","emit","auth","_ssl","ssl","_agent","agent","_proxy","proxy","getConnection","Error","markAlive","markDead","createConnection","urlToHost","url","username","password","decodeURIComponent","connection","conn","id","addConnection","Array","isArray","forEach","o","connectionById","find","c","connectionByUrl","href","update","removeConnection","filter","empty","callback","openConnections","close","nodes","newConnections","oldConnections","node","push","ids","map","indexOf","nodesToHost","protocol","Object","keys","hosts","i","len","address","http","publish_address","parts","split","hostname","port","match","slice","roles","reduce","acc","role","assign","MASTER","DATA","INGEST","ML","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\n'use strict'\r\n\r\nconst { URL } = require('url')\r\nconst debug = require('debug')('elasticsearch')\r\nconst Connection = require('../Connection')\r\nconst noop = () => {}\r\n\r\nclass BaseConnectionPool {\r\n  constructor (opts) {\r\n    // list of nodes and weights\r\n    this.connections = []\r\n    // how many nodes we have in our scheduler\r\n    this.size = this.connections.length\r\n    this.Connection = opts.Connection\r\n    this.emit = opts.emit || noop\r\n    this.auth = opts.auth || null\r\n    this._ssl = opts.ssl\r\n    this._agent = opts.agent\r\n    this._proxy = opts.proxy || null\r\n  }\r\n\r\n  getConnection () {\r\n    throw new Error('getConnection must be implemented')\r\n  }\r\n\r\n  markAlive () {\r\n    return this\r\n  }\r\n\r\n  markDead () {\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a new connection instance.\r\n   */\r\n  createConnection (opts) {\r\n    if (typeof opts === 'string') {\r\n      opts = this.urlToHost(opts)\r\n    }\r\n\r\n    if (this.auth !== null) {\r\n      opts.auth = this.auth\r\n    } else if (opts.url.username !== '' && opts.url.password !== '') {\r\n      opts.auth = {\r\n        username: decodeURIComponent(opts.url.username),\r\n        password: decodeURIComponent(opts.url.password)\r\n      }\r\n    }\r\n\r\n    if (opts.ssl == null) opts.ssl = this._ssl\r\n    /* istanbul ignore else */\r\n    if (opts.agent == null) opts.agent = this._agent\r\n    /* istanbul ignore else */\r\n    if (opts.proxy == null) opts.proxy = this._proxy\r\n\r\n    const connection = new this.Connection(opts)\r\n\r\n    for (const conn of this.connections) {\r\n      if (conn.id === connection.id) {\r\n        throw new Error(`Connection with id '${connection.id}' is already present`)\r\n      }\r\n    }\r\n\r\n    return connection\r\n  }\r\n\r\n  /**\r\n   * Adds a new connection to the pool.\r\n   *\r\n   * @param {object|string} host\r\n   * @returns {ConnectionPool}\r\n   */\r\n  addConnection (opts) {\r\n    if (Array.isArray(opts)) {\r\n      return opts.forEach(o => this.addConnection(o))\r\n    }\r\n\r\n    if (typeof opts === 'string') {\r\n      opts = this.urlToHost(opts)\r\n    }\r\n\r\n    const connectionById = this.connections.find(c => c.id === opts.id)\r\n    const connectionByUrl = this.connections.find(c => c.id === opts.url.href)\r\n\r\n    if (connectionById || connectionByUrl) {\r\n      throw new Error(`Connection with id '${opts.id || opts.url.href}' is already present`)\r\n    }\r\n\r\n    this.update([...this.connections, opts])\r\n    return this.connections[this.size - 1]\r\n  }\r\n\r\n  /**\r\n   * Removes a new connection to the pool.\r\n   *\r\n   * @param {object} connection\r\n   * @returns {ConnectionPool}\r\n   */\r\n  removeConnection (connection) {\r\n    debug('Removing connection', connection)\r\n    return this.update(this.connections.filter(c => c.id !== connection.id))\r\n  }\r\n\r\n  /**\r\n   * Empties the connection pool.\r\n   *\r\n   * @returns {ConnectionPool}\r\n   */\r\n  empty (callback) {\r\n    debug('Emptying the connection pool')\r\n    let openConnections = this.size\r\n    this.connections.forEach(connection => {\r\n      connection.close(() => {\r\n        if (--openConnections === 0) {\r\n          this.connections = []\r\n          this.size = this.connections.length\r\n          callback()\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Update the ConnectionPool with new connections.\r\n   *\r\n   * @param {array} array of connections\r\n   * @returns {ConnectionPool}\r\n   */\r\n  update (nodes) {\r\n    debug('Updating the connection pool')\r\n    const newConnections = []\r\n    const oldConnections = []\r\n\r\n    for (const node of nodes) {\r\n      // if we already have a given connection in the pool\r\n      // we mark it as alive and we do not close the connection\r\n      // to avoid socket issues\r\n      const connectionById = this.connections.find(c => c.id === node.id)\r\n      const connectionByUrl = this.connections.find(c => c.id === node.url.href)\r\n      if (connectionById) {\r\n        debug(`The connection with id '${node.id}' is already present`)\r\n        this.markAlive(connectionById)\r\n        newConnections.push(connectionById)\r\n      // in case the user has passed a single url (or an array of urls),\r\n      // the connection id will be the full href; to avoid closing valid connections\r\n      // because are not present in the pool, we check also the node url,\r\n      // and if is already present we update its id with the ES provided one.\r\n      } else if (connectionByUrl) {\r\n        connectionByUrl.id = node.id\r\n        this.markAlive(connectionByUrl)\r\n        newConnections.push(connectionByUrl)\r\n      } else {\r\n        newConnections.push(this.createConnection(node))\r\n      }\r\n    }\r\n\r\n    const ids = nodes.map(c => c.id)\r\n    // remove all the dead connections and old connections\r\n    for (const connection of this.connections) {\r\n      if (ids.indexOf(connection.id) === -1) {\r\n        oldConnections.push(connection)\r\n      }\r\n    }\r\n\r\n    // close old connections\r\n    oldConnections.forEach(connection => connection.close())\r\n\r\n    this.connections = newConnections\r\n    this.size = this.connections.length\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Transforms the nodes objects to a host object.\r\n   *\r\n   * @param {object} nodes\r\n   * @returns {array} hosts\r\n   */\r\n  nodesToHost (nodes, protocol) {\r\n    const ids = Object.keys(nodes)\r\n    const hosts = []\r\n\r\n    for (let i = 0, len = ids.length; i < len; i++) {\r\n      const node = nodes[ids[i]]\r\n      // If there is no protocol in\r\n      // the `publish_address` new URL will throw\r\n      // the publish_address can have two forms:\r\n      //   - ip:port\r\n      //   - hostname/ip:port\r\n      // if we encounter the second case, we should\r\n      // use the hostname instead of the ip\r\n      let address = node.http.publish_address\r\n      const parts = address.split('/')\r\n      // the url is in the form of hostname/ip:port\r\n      if (parts.length > 1) {\r\n        const hostname = parts[0]\r\n        const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1)\r\n        address = `${hostname}:${port}`\r\n      }\r\n\r\n      address = address.slice(0, 4) === 'http'\r\n        /* istanbul ignore next */\r\n        ? address\r\n        : `${protocol}//${address}`\r\n      const roles = node.roles.reduce((acc, role) => {\r\n        acc[role] = true\r\n        return acc\r\n      }, {})\r\n\r\n      hosts.push({\r\n        url: new URL(address),\r\n        id: ids[i],\r\n        roles: Object.assign({\r\n          [Connection.roles.MASTER]: false,\r\n          [Connection.roles.DATA]: false,\r\n          [Connection.roles.INGEST]: false,\r\n          [Connection.roles.ML]: false\r\n        }, roles)\r\n      })\r\n    }\r\n\r\n    return hosts\r\n  }\r\n\r\n  /**\r\n   * Transforms an url string to a host object\r\n   *\r\n   * @param {string} url\r\n   * @returns {object} host\r\n   */\r\n  urlToHost (url) {\r\n    return {\r\n      url: new URL(url)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = BaseConnectionPool\r\n"]},"metadata":{},"sourceType":"module"}