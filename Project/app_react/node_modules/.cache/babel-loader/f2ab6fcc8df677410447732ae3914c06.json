{"ast":null,"code":"/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n'use strict';\n\nconst BaseConnectionPool = require('./BaseConnectionPool');\n\nconst assert = require('assert');\n\nconst debug = require('debug')('elasticsearch');\n\nconst Connection = require('../Connection');\n\nconst noop = () => {};\n\nclass ConnectionPool extends BaseConnectionPool {\n  constructor(opts) {\n    super(opts);\n    this.dead = []; // the resurrect timeout is 60s\n\n    this.resurrectTimeout = 1000 * 60; // number of consecutive failures after which\n    // the timeout doesn't increase\n\n    this.resurrectTimeoutCutoff = 5;\n    this.pingTimeout = opts.pingTimeout;\n    this._sniffEnabled = opts.sniffEnabled || false;\n    const resurrectStrategy = opts.resurrectStrategy || 'ping';\n    this.resurrectStrategy = ConnectionPool.resurrectStrategies[resurrectStrategy];\n    assert(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);\n  }\n  /**\r\n   * Marks a connection as 'alive'.\r\n   * If needed removes the connection from the dead list\r\n   * and then resets the `deadCount`.\r\n   *\r\n   * @param {object} connection\r\n   */\n\n\n  markAlive(connection) {\n    const {\n      id\n    } = connection;\n    debug(`Marking as 'alive' connection '${id}'`);\n    const index = this.dead.indexOf(id);\n    if (index > -1) this.dead.splice(index, 1);\n    connection.status = Connection.statuses.ALIVE;\n    connection.deadCount = 0;\n    connection.resurrectTimeout = 0;\n    return this;\n  }\n  /**\r\n   * Marks a connection as 'dead'.\r\n   * If needed adds the connection to the dead list\r\n   * and then increments the `deadCount`.\r\n   *\r\n   * @param {object} connection\r\n   */\n\n\n  markDead(connection) {\n    const {\n      id\n    } = connection;\n    debug(`Marking as 'dead' connection '${id}'`);\n\n    if (this.dead.indexOf(id) === -1) {\n      // It might happen that `markDead` is called jsut after\n      // a pool update, and in such case we will add to the dead\n      // list a node that no longer exist. The following check verify\n      // that the connection is still part of the pool before\n      // marking it as dead.\n      for (let i = 0; i < this.size; i++) {\n        if (this.connections[i].id === id) {\n          this.dead.push(id);\n          break;\n        }\n      }\n    }\n\n    connection.status = Connection.statuses.DEAD;\n    connection.deadCount++; // resurrectTimeout formula:\n    // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n\n    connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff)); // sort the dead list in ascending order\n    // based on the resurrectTimeout\n\n    this.dead.sort((a, b) => {\n      const conn1 = this.connections.find(c => c.id === a);\n      const conn2 = this.connections.find(c => c.id === b);\n      return conn1.resurrectTimeout - conn2.resurrectTimeout;\n    });\n    return this;\n  }\n  /**\r\n   * If enabled, tries to resurrect a connection with the given\r\n   * resurrect strategy ('ping', 'optimistic', 'none').\r\n   *\r\n   * @param {object} { now, requestId }\r\n   * @param {function} callback (isAlive, connection)\r\n   */\n\n\n  resurrect(opts, callback = noop) {\n    if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    } // the dead list is sorted in ascending order based on the timeout\n    // so the first element will always be the one with the smaller timeout\n\n\n    const connection = this.connections.find(c => c.id === this.dead[0]);\n\n    if ((opts.now || Date.now()) < connection.resurrectTimeout) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n\n    const {\n      id\n    } = connection; // ping strategy\n\n    if (this.resurrectStrategy === 1) {\n      connection.request({\n        method: 'HEAD',\n        path: '/',\n        timeout: this.pingTimeout\n      }, (err, response) => {\n        let isAlive = true;\n        const statusCode = response !== null ? response.statusCode : 0;\n\n        if (err != null || statusCode === 502 || statusCode === 503 || statusCode === 504) {\n          debug(`Resurrect: connection '${id}' is still dead`);\n          this.markDead(connection);\n          isAlive = false;\n        } else {\n          debug(`Resurrect: connection '${id}' is now alive`);\n          this.markAlive(connection);\n        }\n\n        this.emit('resurrect', null, {\n          strategy: 'ping',\n          name: opts.name,\n          request: {\n            id: opts.requestId\n          },\n          isAlive,\n          connection\n        });\n        callback(isAlive, connection);\n      }); // optimistic strategy\n    } else {\n      debug(`Resurrect: optimistic resurrection for connection '${id}'`);\n      this.dead.splice(this.dead.indexOf(id), 1);\n      connection.status = Connection.statuses.ALIVE;\n      this.emit('resurrect', null, {\n        strategy: 'optimistic',\n        name: opts.name,\n        request: {\n          id: opts.requestId\n        },\n        isAlive: true,\n        connection\n      });\n      callback(true, connection); // eslint-disable-line\n    }\n  }\n  /**\r\n   * Returns an alive connection if present,\r\n   * otherwise returns a dead connection.\r\n   * By default it filters the `master` only nodes.\r\n   * It uses the selector to choose which\r\n   * connection return.\r\n   *\r\n   * @param {object} options (filter and selector)\r\n   * @returns {object|null} connection\r\n   */\n\n\n  getConnection(opts = {}) {\n    const filter = opts.filter || (() => true);\n\n    const selector = opts.selector || (c => c[0]);\n\n    this.resurrect({\n      now: opts.now,\n      requestId: opts.requestId,\n      name: opts.name\n    });\n    const noAliveConnections = this.size === this.dead.length; // TODO: can we cache this?\n\n    const connections = [];\n\n    for (let i = 0; i < this.size; i++) {\n      const connection = this.connections[i];\n\n      if (noAliveConnections || connection.status === Connection.statuses.ALIVE) {\n        if (filter(connection) === true) {\n          connections.push(connection);\n        }\n      }\n    }\n\n    if (connections.length === 0) return null;\n    return selector(connections);\n  }\n  /**\r\n   * Empties the connection pool.\r\n   *\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  empty(callback) {\n    super.empty(() => {\n      this.dead = [];\n      callback();\n    });\n  }\n  /**\r\n   * Update the ConnectionPool with new connections.\r\n   *\r\n   * @param {array} array of connections\r\n   * @returns {ConnectionPool}\r\n   */\n\n\n  update(connections) {\n    super.update(connections);\n    this.dead = [];\n    return this;\n  }\n\n}\n\nConnectionPool.resurrectStrategies = {\n  none: 0,\n  ping: 1,\n  optimistic: 2\n};\nmodule.exports = ConnectionPool;","map":{"version":3,"sources":["C:/Users/vince/peer/project/app_react/src/node_modules/@elastic/elasticsearch/lib/pool/ConnectionPool.js"],"names":["BaseConnectionPool","require","assert","debug","Connection","noop","ConnectionPool","constructor","opts","dead","resurrectTimeout","resurrectTimeoutCutoff","pingTimeout","_sniffEnabled","sniffEnabled","resurrectStrategy","resurrectStrategies","markAlive","connection","id","index","indexOf","splice","status","statuses","ALIVE","deadCount","markDead","i","size","connections","push","DEAD","Date","now","Math","pow","min","sort","a","b","conn1","find","c","conn2","resurrect","callback","length","request","method","path","timeout","err","response","isAlive","statusCode","emit","strategy","name","requestId","getConnection","filter","selector","noAliveConnections","empty","update","none","ping","optimistic","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Licensed to Elasticsearch B.V. under one or more contributor\r\n * license agreements. See the NOTICE file distributed with\r\n * this work for additional information regarding copyright\r\n * ownership. Elasticsearch B.V. licenses this file to you under\r\n * the Apache License, Version 2.0 (the \"License\"); you may\r\n * not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\n'use strict'\r\n\r\nconst BaseConnectionPool = require('./BaseConnectionPool')\r\nconst assert = require('assert')\r\nconst debug = require('debug')('elasticsearch')\r\nconst Connection = require('../Connection')\r\nconst noop = () => {}\r\n\r\nclass ConnectionPool extends BaseConnectionPool {\r\n  constructor (opts) {\r\n    super(opts)\r\n\r\n    this.dead = []\r\n    // the resurrect timeout is 60s\r\n    this.resurrectTimeout = 1000 * 60\r\n    // number of consecutive failures after which\r\n    // the timeout doesn't increase\r\n    this.resurrectTimeoutCutoff = 5\r\n    this.pingTimeout = opts.pingTimeout\r\n    this._sniffEnabled = opts.sniffEnabled || false\r\n\r\n    const resurrectStrategy = opts.resurrectStrategy || 'ping'\r\n    this.resurrectStrategy = ConnectionPool.resurrectStrategies[resurrectStrategy]\r\n    assert(\r\n      this.resurrectStrategy != null,\r\n      `Invalid resurrection strategy: '${resurrectStrategy}'`\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Marks a connection as 'alive'.\r\n   * If needed removes the connection from the dead list\r\n   * and then resets the `deadCount`.\r\n   *\r\n   * @param {object} connection\r\n   */\r\n  markAlive (connection) {\r\n    const { id } = connection\r\n    debug(`Marking as 'alive' connection '${id}'`)\r\n    const index = this.dead.indexOf(id)\r\n    if (index > -1) this.dead.splice(index, 1)\r\n    connection.status = Connection.statuses.ALIVE\r\n    connection.deadCount = 0\r\n    connection.resurrectTimeout = 0\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Marks a connection as 'dead'.\r\n   * If needed adds the connection to the dead list\r\n   * and then increments the `deadCount`.\r\n   *\r\n   * @param {object} connection\r\n   */\r\n  markDead (connection) {\r\n    const { id } = connection\r\n    debug(`Marking as 'dead' connection '${id}'`)\r\n    if (this.dead.indexOf(id) === -1) {\r\n      // It might happen that `markDead` is called jsut after\r\n      // a pool update, and in such case we will add to the dead\r\n      // list a node that no longer exist. The following check verify\r\n      // that the connection is still part of the pool before\r\n      // marking it as dead.\r\n      for (let i = 0; i < this.size; i++) {\r\n        if (this.connections[i].id === id) {\r\n          this.dead.push(id)\r\n          break\r\n        }\r\n      }\r\n    }\r\n    connection.status = Connection.statuses.DEAD\r\n    connection.deadCount++\r\n    // resurrectTimeout formula:\r\n    // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\r\n    connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(\r\n      2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff)\r\n    )\r\n\r\n    // sort the dead list in ascending order\r\n    // based on the resurrectTimeout\r\n    this.dead.sort((a, b) => {\r\n      const conn1 = this.connections.find(c => c.id === a)\r\n      const conn2 = this.connections.find(c => c.id === b)\r\n      return conn1.resurrectTimeout - conn2.resurrectTimeout\r\n    })\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * If enabled, tries to resurrect a connection with the given\r\n   * resurrect strategy ('ping', 'optimistic', 'none').\r\n   *\r\n   * @param {object} { now, requestId }\r\n   * @param {function} callback (isAlive, connection)\r\n   */\r\n  resurrect (opts, callback = noop) {\r\n    if (this.resurrectStrategy === 0 || this.dead.length === 0) {\r\n      debug('Nothing to resurrect')\r\n      callback(null, null)\r\n      return\r\n    }\r\n\r\n    // the dead list is sorted in ascending order based on the timeout\r\n    // so the first element will always be the one with the smaller timeout\r\n    const connection = this.connections.find(c => c.id === this.dead[0])\r\n    if ((opts.now || Date.now()) < connection.resurrectTimeout) {\r\n      debug('Nothing to resurrect')\r\n      callback(null, null)\r\n      return\r\n    }\r\n\r\n    const { id } = connection\r\n\r\n    // ping strategy\r\n    if (this.resurrectStrategy === 1) {\r\n      connection.request({\r\n        method: 'HEAD',\r\n        path: '/',\r\n        timeout: this.pingTimeout\r\n      }, (err, response) => {\r\n        let isAlive = true\r\n        const statusCode = response !== null ? response.statusCode : 0\r\n        if (err != null ||\r\n           (statusCode === 502 || statusCode === 503 || statusCode === 504)) {\r\n          debug(`Resurrect: connection '${id}' is still dead`)\r\n          this.markDead(connection)\r\n          isAlive = false\r\n        } else {\r\n          debug(`Resurrect: connection '${id}' is now alive`)\r\n          this.markAlive(connection)\r\n        }\r\n        this.emit('resurrect', null, {\r\n          strategy: 'ping',\r\n          name: opts.name,\r\n          request: { id: opts.requestId },\r\n          isAlive,\r\n          connection\r\n        })\r\n        callback(isAlive, connection)\r\n      })\r\n    // optimistic strategy\r\n    } else {\r\n      debug(`Resurrect: optimistic resurrection for connection '${id}'`)\r\n      this.dead.splice(this.dead.indexOf(id), 1)\r\n      connection.status = Connection.statuses.ALIVE\r\n      this.emit('resurrect', null, {\r\n        strategy: 'optimistic',\r\n        name: opts.name,\r\n        request: { id: opts.requestId },\r\n        isAlive: true,\r\n        connection\r\n      })\r\n      callback(true, connection) // eslint-disable-line\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an alive connection if present,\r\n   * otherwise returns a dead connection.\r\n   * By default it filters the `master` only nodes.\r\n   * It uses the selector to choose which\r\n   * connection return.\r\n   *\r\n   * @param {object} options (filter and selector)\r\n   * @returns {object|null} connection\r\n   */\r\n  getConnection (opts = {}) {\r\n    const filter = opts.filter || (() => true)\r\n    const selector = opts.selector || (c => c[0])\r\n\r\n    this.resurrect({\r\n      now: opts.now,\r\n      requestId: opts.requestId,\r\n      name: opts.name\r\n    })\r\n\r\n    const noAliveConnections = this.size === this.dead.length\r\n\r\n    // TODO: can we cache this?\r\n    const connections = []\r\n    for (let i = 0; i < this.size; i++) {\r\n      const connection = this.connections[i]\r\n      if (noAliveConnections || connection.status === Connection.statuses.ALIVE) {\r\n        if (filter(connection) === true) {\r\n          connections.push(connection)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (connections.length === 0) return null\r\n\r\n    return selector(connections)\r\n  }\r\n\r\n  /**\r\n   * Empties the connection pool.\r\n   *\r\n   * @returns {ConnectionPool}\r\n   */\r\n  empty (callback) {\r\n    super.empty(() => {\r\n      this.dead = []\r\n      callback()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Update the ConnectionPool with new connections.\r\n   *\r\n   * @param {array} array of connections\r\n   * @returns {ConnectionPool}\r\n   */\r\n  update (connections) {\r\n    super.update(connections)\r\n    this.dead = []\r\n    return this\r\n  }\r\n}\r\n\r\nConnectionPool.resurrectStrategies = {\r\n  none: 0,\r\n  ping: 1,\r\n  optimistic: 2\r\n}\r\n\r\nmodule.exports = ConnectionPool\r\n"]},"metadata":{},"sourceType":"module"}